<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Live View</title>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.*/css/pico.min.css">
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--pico-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif);
            line-height: 1.6;
            color: var(--pico-color, #e0e6ed);
            background-color: var(--pico-background-color, #1f2933);
            padding: 2rem;
            font-size: 0.95rem;
        }

        .mermaid .cluster rect {
            fill: #263442 !important;
        }

        svg .mermaid .cluster rect {
            fill: red;
        }

        .loading {
            background-color: #212830 !important;
        }

        .vega-diagram {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
        }

        .vega-diagram canvas,
        .vega-diagram svg {
            border-radius: 4px;
        }

        .excalidraw-diagram {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            margin: 16px 0;
            min-height: 320px;
            display: flex;
        }

        .excalidraw-wrapper {
            flex: 1;
        }

        /* Excalidraw dark theme variables (sourced from upstream theme.scss) */
        .excalidraw.theme--dark.theme--dark-background-none {
            background: none;
        }

        .excalidraw.theme--dark {
            --theme-filter: invert(93%) hue-rotate(180deg);
            --button-destructive-bg-color: #5a0000;
            --button-destructive-color: #ffa8a8;
            --button-gray-1: #363636;
            --button-gray-2: #272727;
            --button-gray-3: #222;
            --button-special-active-bg-color: #204624;
            --dialog-border-color: var(--color-gray-80);
            --dropdown-icon: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="292.4" height="292.4" viewBox="0 0 292 292"><path fill="%23ced4da" d="M287 197L159 69c-4-3-8-5-13-5s-9 2-13 5L5 197c-3 4-5 8-5 13s2 9 5 13c4 4 8 5 13 5h256c5 0 9-1 13-5s5-8 5-13-1-9-5-13z"/></svg>');
            --focus-highlight-color: #228be6;
            --icon-green-fill-color: #69db7c;
            --default-bg-color: #121212;
            --input-bg-color: #121212;
            --input-border-color: #2e2e2e;
            --input-hover-bg-color: #181818;
            --input-label-color: #e9ecef;
            --island-bg-color: #232329;
            --keybinding-color: var(--color-gray-60);
            --link-color: #4dabf7;
            --overlay-bg-color: rgba(52, 58, 64, 0.12);
            --popup-secondary-bg-color: #222;
            --popup-text-color: #ced4da;
            --popup-text-inverted-color: #2c2c2c;
            --select-highlight-color: #4dabf7;
            --shadow-island: 0px 0px 0.9310142993927002px 0px rgba(0, 0, 0, 0.17),
                0px 0px 3.1270833015441895px 0px rgba(0, 0, 0, 0.08),
                0px 7px 14px 0px rgba(0, 0, 0, 0.05);
            --modal-shadow: 0px 100px 80px rgba(0, 0, 0, 0.07),
                0px 41.7776px 33.4221px rgba(0, 0, 0, 0.0503198),
                0px 22.3363px 17.869px rgba(0, 0, 0, 0.0417275),
                0px 12.5216px 10.0172px rgba(0, 0, 0, 0.035),
                0px 6.6501px 5.32008px rgba(0, 0, 0, 0.0282725),
                0px 2.76726px 2.21381px rgba(0, 0, 0, 0.0196802);
            --avatar-border-color: var(--color-gray-85);
            --scrollbar-thumb: #343a40;
            --scrollbar-thumb-hover: #495057;
            --color-slider-track: hsl(244, 23%, 39%);
            --color-selection: #3530c4;
            --color-icon-white: var(--color-gray-90);
            --color-primary: #a8a5ff;
            --color-primary-darker: #b2aeff;
            --color-primary-darkest: #beb9ff;
            --color-primary-light: #4f4d6f;
            --color-primary-light-darker: #43415e;
            --color-primary-hover: #bbb8ff;
            --color-disabled: var(--color-gray-70);
            --color-text-warning: var(--color-gray-80);
            --color-danger: #ffa8a5;
            --color-danger-dark: #672120;
            --color-danger-darker: #8f2625;
            --color-danger-darkest: #ac2b29;
            --color-danger-text: #fbcbcc;
            --color-danger-background: #fbcbcc;
            --color-danger-icon-background: #672120;
            --color-danger-color: #261919;
            --color-danger-icon-color: #fbcbcc;
            --color-warning-background: var(--color-warning);
            --color-warning-icon-background: var(--color-warning-dark);
            --color-warning-color: var(--color-gray-80);
            --color-warning-icon-color: var(--color-gray-80);
            --color-muted: var(--color-gray-80);
            --color-muted-darker: var(--color-gray-60);
            --color-muted-darkest: var(--color-gray-20);
            --color-muted-background: var(--color-gray-40);
            --color-muted-background-darker: var(--color-gray-20);
            --color-logo-text: #e2dfff;
            --color-surface-high: #2e2d39;
            --color-surface-low: hsl(240, 8%, 15%);
            --color-surface-mid: hsl(240 6% 10%);
            --color-surface-lowest: hsl(0, 0%, 7%);
            --color-on-surface: #e3e3e8;
            --color-brand-hover: #bbb8ff;
            --color-on-primary-container: #e0dfff;
            --color-surface-primary-container: #403e6a;
            --color-brand-active: #d0ccff;
            --color-border-outline: #8e8d9c;
            --color-border-outline-variant: #46464f;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(255, 255, 255, 0.04);
            border-radius: var(--pico-border-radius, 0.75rem);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 1rem 1.25rem;
            margin-bottom: 1.25rem;
            backdrop-filter: blur(6px);
        }

        .directory-info {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem 1.5rem;
        }

        .directory-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.25rem;
            font-weight: 500;
        }

        .directory-meta span {
            color: var(--pico-muted-color, #9ca3af);
        }

        .directory-meta strong {
            color: var(--pico-color, #f9fafb);
            margin-right: 0.35rem;
        }

        /* Chat input styles */
        .chat-container {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .chat-input {
            flex: 1;
            min-width: 220px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--pico-border-radius, 0.5rem);
            padding: 0.75rem 1rem;
            color: var(--pico-color, #f9fafb);
            font-size: 1rem;
            font-family: inherit;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .chat-input:focus {
            border-color: var(--pico-primary, #60a5fa);
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
        }

        .chat-input::placeholder {
            color: var(--pico-muted-color, #9ca3af);
        }

        .chat-send-btn {
            padding: 0.75rem 1.5rem;
            background: var(--pico-primary, #60a5fa);
            border: 1px solid var(--pico-primary, #60a5fa);
            border-radius: var(--pico-border-radius, 0.5rem);
            color: var(--pico-primary-inverse, #0b1120);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, filter 0.2s ease;
            white-space: nowrap;
        }

        .chat-send-btn:hover {
            filter: brightness(1.05);
        }

        .chat-send-btn:active {
            transform: scale(0.97);
        }

        .chat-send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #content {
            background: #0d1117;
            padding: 0px;
            min-height: 400px;
        }

        /* Markdown styles */
        #content h1,
        #content h2,
        #content h3,
        #content h4,
        #content h5,
        #content h6 {
            color: #f0f6fc;
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }

        #content h1 {
            font-size: 2rem;
            border-bottom: 1px solid #21262d;
            padding-bottom: 8px;
        }

        #content h2 {
            font-size: 1.5rem;
            border-bottom: 1px solid #21262d;
            padding-bottom: 8px;
        }

        #content p {
            margin-bottom: 16px;
        }

        #content ul,
        #content ol {
            margin-bottom: 16px;
            padding-left: 32px;
        }

        #content li {
            margin-bottom: 4px;
        }

        #content blockquote {
            margin: 16px 0;
            padding: 0 16px;
            border-left: 4px solid #58a6ff;
            color: #7d8590;
        }

        #content code {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 2px 6px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 85%;
        }

        #content pre {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 16px;
            overflow-x: auto;
            margin: 16px 0;
        }

        #content pre code {
            background: none;
            border: none;
            padding: 0;
            font-size: 85%;
        }

        #content a {
            color: #58a6ff;
            text-decoration: none;
        }

        #content a:hover {
            text-decoration: underline;
        }

        #content table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
        }

        #content th,
        #content td {
            border: 1px solid #30363d;
            padding: 8px 12px;
            text-align: left;
        }

        #content th {
            background: #161b22;
            font-weight: 600;
        }

        #content hr {
            border: none;
            border-top: 1px solid #30363d;
            margin: 24px 0;
        }

        /* Mermaid diagram styles */
        .mermaid {
            text-align: center;
            margin: 20px 0;
        }

        /* Status indicator */
        .status {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.35rem 1rem;
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .status.connected {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
        }

        .status.disconnected {
            background: rgba(248, 113, 113, 0.15);
            color: #f87171;
        }

        .status.connecting {
            background: rgba(96, 165, 250, 0.15);
            color: #93c5fd;
        }

        /* Loading animation */
        .loading {
            text-align: left;
            color: #a0a5ad;
        }

        /* Code highlighting */
        .hljs {
            background: #161b22 !important;
        }

        /* File action buttons */
        .file-block {
            position: relative;
            margin-bottom: 40px;
        }

        .file-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            margin: 0;
            padding: 0.5rem 0;
        }

        .file-name {
            flex: 1;
            color: var(--pico-color, #f9fafb);
            font-weight: 600;
            font-size: 0.95rem;
        }

        .action-btn {
            padding: 0.55rem 1rem;
            border: 1px solid var(--pico-primary, #60a5fa);
            border-radius: var(--pico-border-radius, 0.5rem);
            background: var(--pico-primary, #60a5fa);
            color: var(--pico-primary-inverse, #0b1120);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: filter 0.2s ease, transform 0.2s ease, opacity 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .file-actions .action-btn {
            opacity: 0;
            pointer-events: none;
        }

        .file-actions:hover .action-btn,
        .file-actions:focus-within .action-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .action-btn:hover {
            filter: brightness(1.08);
        }

        .action-btn:active {
            transform: scale(0.97);
        }

        .action-btn.sticky.active {
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.35);
        }

        .action-btn.expand {
            min-width: 40px;
        }

        .action-btn.markdown-toggle.raw-mode {
            box-shadow: inset 0 0 0 2px rgba(15, 23, 42, 0.25);
        }

        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .file-content.raw-mode {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 16px;
            color: #e0e6ed;
            font-size: 0.9em;
        }

        .file-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
        }

        .file-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/14.1.2/marked.min.js" defer=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.1/mermaid.min.js" defer=""></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" defer=""></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@excalidraw/excalidraw@0.18.0/dist/prod/index.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" defer=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"
        defer=""></script>
    <script src="https://cdn.jsdelivr.net/npm/@excalidraw/excalidraw@0.17.4/dist/excalidraw.production.min.js"
        defer=""></script>
    <script src="https://cdn.jsdelivr.net/npm/vega@5.25.0/build/vega.min.js" defer=""></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.15.0/build/vega-lite.min.js" defer=""></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.22.2/build/vega-embed.min.js" defer=""></script>
    <script>
        window.addEventListener('DOMContentLoaded', () => {
            let ws = null;
            let reconnectAttempts = 0;
            const maxReconnectAttempts = 5;
            let mermaidReady = false;
            let vegaReady = false;
            let excalidrawReady = false;
            let mermaidIdCounter = 0;
            let vegaIdCounter = 0;
            let excalidrawIdCounter = 0;
            let markedConfigured = false;
            const textEncoder = new TextEncoder();
            const textDecoder = new TextDecoder();
            const vegaDarkBaseConfig = {
                background: '#0d1117',
                view: {
                    stroke: '#30363d'
                },
                axis: {
                    gridColor: '#30363d',
                    tickColor: '#6e7681',
                    domainColor: '#30363d',
                    labelColor: '#c9d1d9',
                    titleColor: '#c9d1d9'
                },
                legend: {
                    labelColor: '#c9d1d9',
                    titleColor: '#c9d1d9'
                },
                header: {
                    labelColor: '#c9d1d9',
                    titleColor: '#c9d1d9'
                },
                title: {
                    color: '#e6edf3'
                },
                range: {
                    category: ['#58a6ff', '#f778ba', '#8b949e', '#d29922', '#ffa657', '#56d364', '#6fddff', '#ff7b72']
                }
            };

            function waitForLibraries(maxRetries = 50, intervalMs = 100) {
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const check = () => {
                        if (typeof marked !== 'undefined' && typeof mermaid !== 'undefined' && typeof hljs !== 'undefined') {
                            resolve();
                        } else if (attempts >= maxRetries) {
                            reject(new Error('Required libraries failed to load'));
                        } else {
                            attempts += 1;
                            setTimeout(check, intervalMs);
                        }
                    };
                    check();
                });
            }

            function initializeMermaid() {
                if (typeof mermaid === 'undefined') {
                    console.warn('Mermaid not available');
                    mermaidReady = false;
                    return;
                }

                try {
                    mermaid.initialize({
                        startOnLoad: false,
                        theme: 'dark',
                        securityLevel: 'loose',
                        themeVariables: {
                            background: '#121a22',
                            primaryColor: '#1f2a33',
                            secondaryColor: '#253548',
                            primaryTextColor: '#e0e6ed',
                            primaryBorderColor: '#3d4f5c',
                            lineColor: '#7d8590',
                            tertiaryColor: '#161b22',
                            cScale0: '#58a6ff',
                            cScale1: '#79c0ff',
                            cScale2: '#a5f3fc'
                        }
                    });
                    mermaidReady = true;
                    console.log('Mermaid initialized successfully');
                    requestAnimationFrame(renderMermaidDiagrams);
                } catch (error) {
                    console.error('Failed to initialize Mermaid:', error);
                    mermaidReady = false;
                }
            }

            function escapeHtml(value) {
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function encodeDiagramSource(code) {
                if (!code) {
                    return '';
                }
                const bytes = textEncoder.encode(code);
                let binary = '';
                bytes.forEach(byte => {
                    binary += String.fromCharCode(byte);
                });
                return btoa(binary);
            }

            function decodeDiagramSource(encoded, label = 'diagram') {
                if (!encoded) {
                    return '';
                }
                try {
                    const bytes = Uint8Array.from(atob(encoded), char => char.charCodeAt(0));
                    return textDecoder.decode(bytes);
                } catch (error) {
                    console.warn(`Failed to decode ${label} source`, error);
                    return '';
                }
            }

            function encodeMermaidSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeMermaidSource(encoded) {
                return decodeDiagramSource(encoded, 'Mermaid');
            }

            function encodeVegaSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeVegaSource(encoded) {
                return decodeDiagramSource(encoded, 'Vega');
            }

            function encodeExcalidrawSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeExcalidrawSource(encoded) {
                return decodeDiagramSource(encoded, 'Excalidraw');
            }

            function setupMarked() {
                if (typeof marked === 'undefined') {
                    console.warn('Marked not available');
                    return;
                }

                if (!markedConfigured) {
                    marked.use({
                        walkTokens(token) {
                            if (token && token.type === 'code') {
                                const langInput = typeof token.lang === 'string' ? token.lang : '';
                                const lang = langInput.toLowerCase();
                                if (lang.includes('mermaid')) {
                                    const id = `mermaid-${mermaidIdCounter++}`;
                                    const encodedSource = encodeMermaidSource(token.text || token.raw || '');
                                    const mermaidHtml = `<div class="mermaid" id="${id}" data-mermaid-source="${encodedSource}"></div>`;
                                    token.type = 'html';
                                    token.raw = mermaidHtml;
                                    token.text = mermaidHtml;
                                } else if (lang.includes('vega-lite') || lang === 'vega') {
                                    const id = `vega-${vegaIdCounter++}`;
                                    const encodedSource = encodeVegaSource(token.text || token.raw || '');
                                    const vegaHtml = `<div class="vega-diagram" id="${id}" data-vega-source="${encodedSource}"></div>`;
                                    token.type = 'html';
                                    token.raw = vegaHtml;
                                    token.text = vegaHtml;
                                } else if (lang.includes('excalidraw')) {
                                    const id = `excalidraw-${excalidrawIdCounter++}`;
                                    const encodedSource = encodeExcalidrawSource(token.text || token.raw || '');
                                    const excalidrawHtml = `<div class="excalidraw-diagram" id="${id}" data-excalidraw-source="${encodedSource}"></div>`;
                                    token.type = 'html';
                                    token.raw = excalidrawHtml;
                                    token.text = excalidrawHtml;
                                }
                            }
                        }
                    });

                    marked.setOptions({
                        highlight: function (code, lang) {
                            if (typeof hljs !== 'undefined' && lang && hljs.getLanguage(lang)) {
                                try {
                                    return hljs.highlight(code, { language: lang }).value;
                                } catch (err) {
                                    console.warn('Highlight.js error:', err);
                                }
                            }
                            return code;
                        },
                        breaks: true,
                        gfm: true
                    });

                    markedConfigured = true;
                }
            }

            function renderMermaidDiagrams() {
                const mermaidElements = document.querySelectorAll('.mermaid');
                if (!mermaidElements.length) {
                    return;
                }

                if (mermaidReady && typeof mermaid !== 'undefined') {
                    mermaidElements.forEach((element) => {
                        const encoded = element.getAttribute('data-mermaid-source');
                        const sourceContent = encoded ? decodeMermaidSource(encoded) : element.textContent;
                        if (!sourceContent.trim()) {
                            return;
                        }
                        mermaid.render(`${element.id}-svg`, sourceContent)
                            .then(({ svg }) => {
                                element.innerHTML = svg;
                            })
                            .catch((error) => {
                                console.error('Mermaid rendering error:', error);
                                element.innerHTML = `<div style="color: #cf222e; border: 1px solid #cf222e; padding: 10px; border-radius: 4px;">Mermaid rendering error: ${escapeHtml(error.message)}</div>`;
                            });
                    });
                } else {
                    mermaidElements.forEach((element) => {
                        const encoded = element.getAttribute('data-mermaid-source');
                        const sourceContent = encoded ? decodeMermaidSource(encoded) : element.textContent;
                        element.innerHTML = `<div class="loading">📊 Mermaid diagram (awaiting Mermaid.js):<br><pre>${escapeHtml(sourceContent)}</pre></div>`;
                    });
                }
            }

            function initializeVega(retryCount = 0) {
                if (typeof vega === 'undefined' || typeof vegaLite === 'undefined' || typeof vegaEmbed === 'undefined') {
                    if (retryCount < 10) {
                        setTimeout(() => initializeVega(retryCount + 1), 200);
                    } else {
                        console.warn('Vega libraries not available');
                    }
                    vegaReady = false;
                    return;
                }

                vegaReady = true;
                console.log('Vega initialized successfully');
                requestAnimationFrame(renderVegaVisualizations);
            }

            function renderVegaVisualizations() {
                const vegaElements = document.querySelectorAll('.vega-diagram');
                if (!vegaElements.length) {
                    return;
                }

                if (vegaReady && typeof vegaEmbed !== 'undefined') {
                    vegaElements.forEach((element) => {
                        if (element.dataset.rendered === 'true') {
                            return;
                        }

                        const encoded = element.getAttribute('data-vega-source');
                        const sourceContent = encoded ? decodeVegaSource(encoded) : element.textContent;

                        if (!sourceContent.trim()) {
                            element.innerHTML = '<div class="loading">⚠️ Vega spec is empty.</div>';
                            element.dataset.rendered = 'true';
                            return;
                        }

                        let spec;
                        try {
                            spec = JSON.parse(sourceContent);
                        } catch (error) {
                            console.error('Vega parsing error:', error);
                            element.innerHTML = `<div style="color: #cf222e; border: 1px solid #cf222e; padding: 10px; border-radius: 4px;">Invalid Vega specification:<br><pre>${escapeHtml(sourceContent)}</pre></div>`;
                            element.dataset.rendered = 'true';
                            return;
                        }

                        element.innerHTML = '';
                        const target = document.createElement('div');
                        element.appendChild(target);

                        const embedOptions = {
                            actions: false,
                            renderer: 'canvas',
                            theme: 'dark',
                            config: { ...vegaDarkBaseConfig }
                        };

                        vegaEmbed(target, spec, embedOptions)
                            .then(() => {
                                element.dataset.rendered = 'true';
                            })
                            .catch((error) => {
                                console.error('Vega rendering error:', error);
                                element.innerHTML = `<div style="color: #cf222e; border: 1px solid #cf222e; padding: 10px; border-radius: 4px;">Vega rendering error: ${escapeHtml(error.message)}</div>`;
                                element.dataset.rendered = 'true';
                            });
                    });
                } else {
                    vegaElements.forEach((element) => {
                        const encoded = element.getAttribute('data-vega-source');
                        const sourceContent = encoded ? decodeVegaSource(encoded) : element.textContent;
                        element.innerHTML = `<div class="loading">📈 Vega visualization (awaiting Vega libraries):<br><pre>${escapeHtml(sourceContent)}</pre></div>`;
                    });
                }
            }

            function initializeExcalidraw(retryCount = 0) {
                if (typeof window.React === 'undefined' || typeof window.ReactDOM === 'undefined' || typeof window.ExcalidrawLib === 'undefined') {
                    if (retryCount < 10) {
                        setTimeout(() => initializeExcalidraw(retryCount + 1), 200);
                    } else {
                        console.warn('Excalidraw libraries not available');
                    }
                    excalidrawReady = false;
                    return;
                }

                excalidrawReady = true;
                console.log('Excalidraw initialized successfully');
                requestAnimationFrame(renderExcalidrawDiagrams);
            }

            function renderExcalidrawDiagrams() {
                const excalidrawElements = document.querySelectorAll('.excalidraw-diagram');
                if (!excalidrawElements.length) {
                    return;
                }

                if (excalidrawReady && window.React && window.ReactDOM && window.ExcalidrawLib && window.ExcalidrawLib.Excalidraw) {
                    excalidrawElements.forEach((element) => {
                        if (element.dataset.rendered === 'true') {
                            return;
                        }

                        const encoded = element.getAttribute('data-excalidraw-source');
                        const sourceContent = encoded ? decodeExcalidrawSource(encoded) : element.textContent;

                        if (!sourceContent.trim()) {
                            element.innerHTML = '<div class="loading">⚠️ Excalidraw scene is empty.</div>';
                            element.dataset.rendered = 'true';
                            return;
                        }

                        let sceneData;
                        try {
                            sceneData = JSON.parse(sourceContent);
                        } catch (error) {
                            console.error('Excalidraw parsing error:', error);
                            element.innerHTML = `<div style="color: #cf222e; border: 1px solid #cf222e; padding: 10px; border-radius: 4px;">Invalid Excalidraw JSON:<br><pre>${escapeHtml(sourceContent)}</pre></div>`;
                            element.dataset.rendered = 'true';
                            return;
                        }

                        element.innerHTML = '';
                        const wrapper = document.createElement('div');
                        wrapper.className = 'excalidraw-wrapper';
                        wrapper.style.height = '480px';
                        element.appendChild(wrapper);

                        try {
                            const defaultAppState = {
                                theme: 'dark',
                                viewBackgroundColor: '#0d1117',
                                currentItemStrokeColor: '#58a6ff',
                                currentItemBackgroundColor: 'transparent',
                                currentItemFillStyle: 'hachure'
                            };

                            const mergedAppState = {
                                ...defaultAppState,
                                ...(sceneData.appState || {}),
                                theme: 'dark',
                                viewBackgroundColor: sceneData.appState?.viewBackgroundColor || '#0d1117'
                            };

                            const initialData = {
                                ...sceneData,
                                appState: mergedAppState
                            };

                            const excalidrawElement = React.createElement(window.ExcalidrawLib.Excalidraw, {
                                initialData,
                                viewModeEnabled: true,
                                zenModeEnabled: false,
                                gridModeEnabled: Boolean(mergedAppState.gridSize),
                                theme: 'dark'
                            });

                            if (typeof window.ReactDOM.createRoot === 'function') {
                                const root = window.ReactDOM.createRoot(wrapper);
                                root.render(excalidrawElement);
                                element.dataset.rendered = 'true';
                                element._excalidrawRoot = root;
                            } else {
                                window.ReactDOM.render(excalidrawElement, wrapper);
                                element.dataset.rendered = 'true';
                            }
                        } catch (error) {
                            console.error('Excalidraw rendering error:', error);
                            element.innerHTML = `<div style="color: #cf222e; border: 1px solid #cf222e; padding: 10px; border-radius: 4px;">Excalidraw rendering error: ${escapeHtml(error.message)}</div>`;
                            element.dataset.rendered = 'true';
                        }
                    });
                } else {
                    excalidrawElements.forEach((element) => {
                        const encoded = element.getAttribute('data-excalidraw-source');
                        const sourceContent = encoded ? decodeExcalidrawSource(encoded) : element.textContent;
                        element.innerHTML = `<div class="loading">✏️ Excalidraw scene (awaiting Excalidraw libraries):<br><pre>${escapeHtml(sourceContent)}</pre></div>`;
                    });
                }
            }

            function updateStatus(connected) {
                const status = document.querySelector('[data-role="status"]') || createStatusElement();
                if (!status) {
                    return;
                }

                if (connected) {
                    status.textContent = 'Connected';
                    status.className = 'status connected';
                } else {
                    status.textContent = 'Disconnected';
                    status.className = 'status disconnected';
                }
            }

            function createStatusElement() {
                const container = document.querySelector('.directory-info');
                if (!container) {
                    return null;
                }

                const status = document.createElement('span');
                status.className = 'status connecting';
                status.setAttribute('data-role', 'status');
                status.textContent = 'Connecting…';
                container.appendChild(status);
                return status;
            }

            function connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws${window.location.search}`;

                ws = new WebSocket(wsUrl);

                ws.onopen = function () {
                    console.log('WebSocket connected');
                    updateStatus(true);
                    reconnectAttempts = 0;
                    loadContent();
                };

                ws.onmessage = function (event) {
                    console.log('Received WebSocket message:', event.data);
                    const data = JSON.parse(event.data);
                    if (data.type === 'content_update') {
                        updateContent(data.content);
                    }
                };

                ws.onclose = function () {
                    console.log('WebSocket disconnected');
                    updateStatus(false);
                    attemptReconnect();
                };

                ws.onerror = function (error) {
                    console.error('WebSocket error:', error);
                    updateStatus(false);
                };
            }

            function attemptReconnect() {
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    console.log(`Attempting to reconnect... (${reconnectAttempts}/${maxReconnectAttempts})`);
                    setTimeout(connectWebSocket, Math.pow(2, reconnectAttempts) * 1000);
                } else {
                    console.error('Max reconnection attempts reached');
                }
            }

            async function loadContent() {
                try {
                    const response = await fetch(`/api/content${window.location.search}`);
                    const data = await response.json();

                    // Store file list globally for later use
                    window.fileList = data.fileList || [];

                    updateContent(data.content);

                    // Update directory info
                    const directoryInfo = document.querySelector('.directory-info');
                    if (directoryInfo) {
                        const directorySpan = directoryInfo.querySelector('[data-role="directory"]');
                        const filesSpan = directoryInfo.querySelector('[data-role="files"]');
                        const updatedSpan = directoryInfo.querySelector('[data-role="updated"]');

                        if (directorySpan) {
                            directorySpan.textContent = data.directory;
                        }

                        if (filesSpan) {
                            filesSpan.textContent = data.files;
                        }

                        if (updatedSpan) {
                            updatedSpan.textContent = new Date(data.timestamp * 1000).toLocaleString();
                        }
                    }
                } catch (error) {
                    console.error('Error loading content:', error);
                    document.getElementById('content').innerHTML = '<div class="loading">❌ Error loading content</div>';
                }
            }

            function updateContent(markdownContent) {
                if (typeof marked === 'undefined') {
                    document.getElementById('content').innerHTML = '<div class="loading">⏳ Loading markdown renderer...</div>';
                    return;
                }

                try {
                    mermaidIdCounter = 0;
                    vegaIdCounter = 0;
                    excalidrawIdCounter = 0;

                    // Split content by file separators (---)
                    const sections = markdownContent.split('\n\n---\n\n');
                    const contentDiv = document.getElementById('content');
                    contentDiv.innerHTML = '';

                    sections.forEach((section, index) => {
                        if (!section.trim()) return;

                        // Create a file block container
                        const fileBlock = document.createElement('div');
                        fileBlock.className = 'file-block';

                        // Add action buttons if we have file metadata
                        if (window.fileList && window.fileList[index]) {
                            const fileInfo = window.fileList[index];
                            const actions = document.createElement('div');
                            actions.className = 'panel file-actions';
                            const expandBtnId = `expand-btn-${index}`;
                            const contentId = `content-${index}`;
                            const markdownToggleBtnId = `markdown-toggle-btn-${index}`;
                            const stickyClass = fileInfo.isSticky ? 'active' : '';
                            const stickyLabel = fileInfo.isSticky ? 'Sticky (On)' : 'Sticky';
                            actions.innerHTML = `
                                <button class="action-btn expand" id="${expandBtnId}" onclick="toggleExpand('${contentId}', '${expandBtnId}')">
                                    Collapse
                                </button>
                                <span class="file-name">${escapeHtml(fileInfo.name)}</span>
                                <button class="action-btn markdown-toggle" id="${markdownToggleBtnId}" onclick="toggleMarkdownRaw('${contentId}', '${markdownToggleBtnId}')">
                                    Raw
                                </button>
                                <button class="action-btn sticky ${stickyClass}" onclick="toggleSticky('${escapeHtml(fileInfo.fileId)}')">
                                    ${stickyLabel}
                                </button>
                                <button class="action-btn download" onclick="downloadFileAsPDF('${escapeHtml(fileInfo.fileId)}')">
                                    Download PDF
                                </button>
                                <button class="action-btn delete" onclick="deleteFile('${escapeHtml(fileInfo.fileId)}')">
                                    Delete
                                </button>
                            `;
                            fileBlock.appendChild(actions);
                        }

                        // Add the rendered content
                        const contentSection = document.createElement('div');
                        contentSection.className = 'file-content';
                        contentSection.id = `content-${index}`;
                        contentSection.setAttribute('data-raw-markdown', section);
                        contentSection.innerHTML = marked.parse(section);
                        fileBlock.appendChild(contentSection);

                        contentDiv.appendChild(fileBlock);
                    });

                    // Highlight code blocks
                    if (typeof hljs !== 'undefined') {
                        document.querySelectorAll('pre code').forEach((block) => {
                            if (block.classList.contains('language-mermaid')) {
                                return;
                            }
                            hljs.highlightElement(block);
                        });
                    }

                    renderMermaidDiagrams();
                    renderVegaVisualizations();
                    renderExcalidrawDiagrams();
                } catch (error) {
                    console.error('Error rendering markdown:', error);
                    document.getElementById('content').innerHTML = `<div style="color: #cf222e;">Error rendering markdown: ${error.message}</div>`;
                }
            }

            // Make functions globally accessible by attaching to window
            window.deleteFile = async function (fileId) {
                if (!confirm(`Are you sure you want to delete "${fileId}"?`)) {
                    return;
                }

                try {
                    const response = await fetch(`/api/delete${window.location.search}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fileId: fileId })
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log('File deleted successfully');
                        // Reload content
                        loadContent();
                    } else {
                        alert(`Error deleting file: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Error deleting file:', error);
                    alert(`Error deleting file: ${error.message}`);
                }
            };

            window.downloadFileAsPDF = function (fileId) {
                const url = new URL('/print', window.location.origin);
                url.searchParams.set('fileId', fileId);

                const currentParams = new URLSearchParams(window.location.search);
                const currentPath = currentParams.get('path');
                if (currentPath) {
                    url.searchParams.set('path', currentPath);
                }

                window.open(url.toString(), '_blank');
            };

            window.toggleExpand = function (contentId, btnId) {
                const content = document.getElementById(contentId);
                const btn = document.getElementById(btnId);

                if (content.classList.contains('collapsed')) {
                    content.classList.remove('collapsed');
                    btn.textContent = 'Collapse';
                } else {
                    content.classList.add('collapsed');
                    btn.textContent = 'Expand';
                }
            };

            window.toggleSticky = async function (fileId) {
                try {
                    const response = await fetch(`/api/toggle-sticky${window.location.search}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fileId: fileId })
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log('Sticky status toggled successfully');
                        // Reload content to reflect the change
                        loadContent();
                    } else {
                        alert(`Error toggling sticky: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Error toggling sticky:', error);
                    alert(`Error toggling sticky: ${error.message}`);
                }
            };

            window.toggleMarkdownRaw = function (contentId, btnId) {
                const content = document.getElementById(contentId);
                const btn = document.getElementById(btnId);

                if (!content) return;

                // Check if we're in raw mode
                const isRawMode = content.classList.contains('raw-mode');

                if (isRawMode) {
                    // Switch back to markdown rendered mode
                    const rawText = content.getAttribute('data-raw-markdown');
                    if (rawText) {
                        content.innerHTML = marked.parse(rawText);
                        content.classList.remove('raw-mode');
                        btn.classList.remove('raw-mode');
                        btn.textContent = 'Raw';

                        // Re-highlight code blocks
                        if (typeof hljs !== 'undefined') {
                            content.querySelectorAll('pre code').forEach((block) => {
                                if (!block.classList.contains('language-mermaid')) {
                                    hljs.highlightElement(block);
                                }
                            });
                        }

                        // Re-render mermaid diagrams
                        renderMermaidDiagrams();
                        renderVegaVisualizations();
                        renderExcalidrawDiagrams();
                    }
                } else {
                    // Switch to raw markdown mode
                    const rawText = content.getAttribute('data-raw-markdown');
                    if (rawText) {
                        content.textContent = rawText;
                        content.classList.add('raw-mode');
                        btn.classList.add('raw-mode');
                        btn.textContent = 'Rendered';
                    }
                }
            };

            window.sendChatMessage = function () {
                const input = document.getElementById('chat-input');
                const message = input.value.trim();

                if (!message) {
                    return;
                }

                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    alert('WebSocket not connected. Cannot send message.');
                    return;
                }

                // Send chat message to server via WebSocket
                try {
                    ws.send(JSON.stringify({
                        type: 'chat',
                        message: message
                    }));

                    console.log('Sent chat message:', message);

                    // Clear input
                    input.value = '';
                } catch (error) {
                    console.error('Error sending chat message:', error);
                    alert(`Error sending message: ${error.message}`);
                }
            };

            window.handleChatKeyPress = function (event) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    sendChatMessage();
                }
            };

            // Initialize everything
            waitForLibraries()
                .then(() => {
                    console.log('All libraries loaded successfully');
                    initializeMermaid();
                    initializeVega();
                    initializeExcalidraw();
                    setupMarked();
                    connectWebSocket();
                    loadContent();
                })
                .catch((error) => {
                    console.error('Failed to load required libraries:', error);
                    document.getElementById('content').innerHTML = '<div class="loading">❌ Failed to load required libraries</div>';
                });
        });
    </script>
</head>

<body data-theme="dark">
    <div class="container">
        <div class="panel directory-info">
            <div class="directory-meta">
                <span><strong>Directory:</strong> <span data-role="directory">__CURRENT_DIRECTORY__</span></span>
                <span><strong>Files:</strong> <span data-role="files">Loading...</span></span>
                <span><strong>Last Updated:</strong> <span data-role="updated">Loading...</span></span>
            </div>
            <span class="status connecting" data-role="status">Connecting…</span>
        </div>

        <div class="panel chat-container">
            <input type="text" id="chat-input" class="chat-input"
                placeholder="Send a message to connected AI agents..." onkeypress="handleChatKeyPress(event)" />
            <button class="chat-send-btn" onclick="sendChatMessage()">Send</button>
        </div>

        <div id="content" class="loading">
            ⏳ Loading content...
        </div>
    </div>
</body>

</html>