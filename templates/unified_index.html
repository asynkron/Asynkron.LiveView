<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
        integrity="sha512-rO+olRTkcf304DQBxSWxln8JXCzTHlKnIdnMUwYvQa9/Jd4cQaNkItIUj6Z4nvW1dqK0SKXLbn9h4KwZTNtAyw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css"
        integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/darcula.min.css"
        integrity="sha512-kqCOYFDdyQF4JM8RddA6rMBi9oaLdR0aEACdB95Xl1EgaBhaXMIe8T4uxmPitfq4qRmHqo+nBU2d1l+M4zUx1g=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css"
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        :root {
            color-scheme: dark;
            --file-sidebar-width: 320px;
            --file-sidebar-min-width: 220px;
            --file-sidebar-max-width: 520px;
            --toc-sidebar-width: 260px;
            --toc-sidebar-min-width: 180px;
            --toc-sidebar-max-width: 420px;
            --sidebar-collapsed-width: 20px;
            --file-sidebar-current-width: var(--sidebar-collapsed-width);
            --toc-sidebar-current-width: var(--sidebar-collapsed-width);
        }

        path {
            stroke: #c0c0c0;

        }

        .cluster rect {
            fill: #80808020 !important;
        }

        * {
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: 100%;
            overflow: hidden;
        }

        a {
            color: #58a6ff;
        }

        .app-shell {
            display: grid;
            grid-template-columns: var(--toc-sidebar-current-width) 10px minmax(0, 1fr) 10px var(--file-sidebar-current-width);
            gap: 0;
            padding: 0;
            min-height: 0;
            height: 100%;
            overflow: hidden;
            flex: 1 1 auto;
        }

        @media (max-width: 980px) {
            .app-shell {
                grid-template-columns: 1fr;
                grid-auto-rows: auto;
            }

            .splitter {
                display: none;
            }

            .sidebar,
            .viewer {
                grid-column: 1 / -1;
            }

            .viewer {
                order: 0;
            }

            .sidebar {
                order: 1;
                height: auto;
                min-height: 0;
            }
        }

        .viewer {
            display: flex;
            flex-direction: column;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 0;
            min-height: 0;
            height: 100%;
            overflow: hidden;
        }

        .file-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
            padding: 16px;
            padding-left: 24px;
            border-bottom: 1px solid #30363d;
            background: #0d1117;
        }

        .file-header h1 {
            margin: 0;
            font-size: 1.6rem;
            color: #58a6ff;
        }

        .file-meta {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .file-meta small {
            color: #8b949e;
        }

        .file-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .file-actions button {
            padding: 10px 14px;
            border-radius: 0;
            border: 1px solid transparent;
            background: #ffffff10;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s ease, background 0.2s ease;
        }

        .file-actions button.secondary {
            background: #30363d;
            color: #c9d1d9;
        }

        .file-actions button.danger {
            background: #da3633;
        }

        .file-actions button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .file-actions button:not(:disabled):hover {
            transform: translateY(-1px);
        }

        .file-button-icon {
            color: #58a6ff;
            font-size: 0.9rem;
            min-width: 16px;
            display: inline-block;
        }

        .status-message {
            color: #ffa657;
            font-size: 0.9rem;
        }

        .content-area {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .content-area.hidden {
            display: none;
        }

        .content-area h1,
        .content-area h2,
        .content-area h3,
        .content-area h4,
        .content-area h5,
        .content-area h6 {
            color: #f0f6fc;
            position: relative;
        }

        .heading-anchor {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: auto;
            height: auto;
            margin-left: 8px;
            color: #8b949e;
            text-decoration: none;
            opacity: 0;
            transition: opacity 0.2s ease, color 0.2s ease;
            font-size: 0.8em;
            font-weight: normal;
        }

        .heading-anchor::before {
            content: "#";
            font-family: inherit;
        }

        .heading-anchor:hover,
        .heading-anchor:focus-visible {
            color: #58a6ff;
            outline: none;
        }

        .content-area h1:hover .heading-anchor,
        .content-area h1:focus-within .heading-anchor,
        .content-area h2:hover .heading-anchor,
        .content-area h2:focus-within .heading-anchor,
        .content-area h3:hover .heading-anchor,
        .content-area h3:focus-within .heading-anchor,
        .content-area h4:hover .heading-anchor,
        .content-area h4:focus-within .heading-anchor,
        .content-area h5:hover .heading-anchor,
        .content-area h5:focus-within .heading-anchor,
        .content-area h6:hover .heading-anchor,
        .content-area h6:focus-within .heading-anchor {
            opacity: 1;
        }

        .content-area code {
            background: #0d1117;
            border-radius: 6px;
            padding: 2px 5px;
        }

        .content-area pre {
            background: #0d1117;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
        }

        .diagram-loading {
            background: #1f242e;
            border: 1px dashed #30363d;
            border-radius: 8px;
            padding: 16px;
            margin: 24px 0;
            color: #8b949e;
            font-size: 0.95rem;
            line-height: 1.5;
            word-break: break-word;
        }

        .diagram-loading pre {
            margin-top: 12px;
            max-height: 320px;
            overflow: auto;
            background: rgba(13, 17, 23, 0.6);
            border-radius: 6px;
            padding: 12px;
        }

        .content-area .mermaid {
            display: block;
            margin: 24px 0;
        }

        .content-area .vega-diagram,
        .content-area .excalidraw-diagram {
            margin: 24px 0;
            position: relative;
            min-height: 120px;
            overflow: hidden;
        }

        .content-area .excalidraw-wrapper {
            width: 100%;
            min-height: 320px;
            height: clamp(320px, 65vh, 640px);
            pointer-events: none;
        }

        .content-area .excalidraw-wrapper canvas {
            pointer-events: none !important;
        }

        .content-area .excalidraw-wrapper .layer-ui__wrapper {
            display: none !important;
        }

        .editor-container {
            display: none;
            flex: 1;
            padding: 24px;
            overflow: hidden;
            min-height: 320px;
            height: 100%;
        }

        .editor-container.visible {
            display: block;
        }

        .editor-container .CodeMirror {
            height: 100%;
            font-size: 0.95rem;
            background: #0d1117;
            color: #c9d1d9;
        }

        .editor-container .CodeMirror-scroll {
            max-height: 100%;
        }

        .editor-container .CodeMirror-gutters {
            background: #0d1117;
            border-right: 1px solid #30363d;
        }

        .editor-container .CodeMirror-cursor {
            border-left: 1px solid #58a6ff;
        }

        .editor-container .CodeMirror-selected {
            background: rgba(88, 166, 255, 0.2);
        }

        .splitter {
            cursor: col-resize;
            background: #21262d;
            position: relative;
        }

        .splitter::after {
            content: '';
            position: absolute;
            top: 20px;
            bottom: 20px;
            left: 50%;
            width: 2px;
            transform: translateX(-50%);
            background: #30363d;
            border-radius: 1px;
        }

        .splitter.dragging::after {
            background: #58a6ff;
        }

        .sidebar {
            position: relative;
            display: flex;
            flex-direction: column;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 0;
            padding: 0;
            gap: 0;
            height: 100%;
            min-height: 0;
            overflow: hidden;
            transition: box-shadow 0.2s ease;
        }

        .sidebar.is-expanded {
            box-shadow: inset 0 0 0 1px rgba(88, 166, 255, 0.2);
        }

        .sidebar-content {
            display: flex;
            flex-direction: column;
            gap: 0;
            height: 100%;
            min-height: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .sidebar.is-expanded .sidebar-content {
            opacity: 1;
            pointer-events: auto;
        }

        .sidebar-collapsed-label {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            font-size: 0.7rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: #8b949e;
            pointer-events: none;
            opacity: 0.65;
            transition: opacity 0.2s ease;
        }

        .sidebar.is-expanded .sidebar-collapsed-label {
            opacity: 0;
        }

        .sidebar.is-expanded .sidebar-collapsed-label::after {
            content: '';
        }

        .sidebar--toc .sidebar-collapsed-label {
            letter-spacing: 0.2em;
        }

        .sidebar--files .sidebar-collapsed-label {
            letter-spacing: 0.16em;
        }

        .sidebar-header {
            position: sticky;
            top: 0;
            background: #161b22;
            z-index: 10;
            padding: 20px 20px 12px 20px;
            border-bottom: 1px solid #30363d;
        }

        .sidebar-title {
            margin: 0;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #c9d1d9;
        }

        .sidebar-path {
            font-size: 0.8rem;
            color: #8b949e;
            word-break: break-all;
            line-height: 1.3;
        }

        .toc-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px 24px;
        }

        .toc-list ol {
            list-style: none;
            margin: 0;
            padding-left: 0;
        }

        .toc-entry {
            margin: 2px 0;
        }

        .toc-link {
            display: block;
            padding: 6px 10px;
            border-radius: 6px;
            color: #c9d1d9;
            text-decoration: none;
            font-size: 0.85rem;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .toc-link:hover,
        .toc-link:focus-visible {
            background: #1f242e;
            color: #58a6ff;
            outline: none;
        }

        .toc-empty-state {
            color: #8b949e;
            font-size: 0.85rem;
            padding: 8px 4px;
        }

        .file-list {
            list-style: none;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .file-list ul {
            list-style: none;
            margin: 4px 0 0;
            padding-left: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .tree-node {
            margin: 0;
        }

        .tree-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 2px 4px;
            background: transparent;
            transition: background 0.2s ease;
        }

        .tree-row:hover {
            background: #1f242e;
        }

        .tree-toggle {
            width: 18px;
            height: 18px;
            border: none;
            background: none;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
        }

        .tree-toggle:focus-visible,
        .tree-label:focus-visible,
        .file-button:focus-visible {
            outline: 2px solid #58a6ff;
            outline-offset: 1px;
        }

        .tree-label {
            flex: 1;
            background: none;
            border: none;
            color: inherit;
            text-align: left;
            cursor: pointer;
            padding: 4px 6px;
            font: inherit;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .directory-icon {
            font-size: 0.9rem;
            color: #58a6ff;
            flex-shrink: 0;
            min-width: 20px;
            text-align: center;
        }

        .directory-label {
            font-weight: normal;
        }

        .tree-children.collapsed {
            display: none;
        }

        .file-button {
            width: 100%;
            background: transparent;
            border: 1px solid transparent;
            color: inherit;
            padding: 6px 10px;
            text-align: left;
            cursor: pointer;
            transition: border 0.2s ease, background 0.2s ease;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-icon {
            font-size: 0.9rem;
            color: #58a6ff;
            flex-shrink: 0;
            min-width: 20px;
            text-align: center;
            margin-left: 8px;
        }

        .file-button:hover {
            background: #1f242e;
        }

        .file-button.active {
            background: #1f242e;
            border-color: #30363d;
            color: #c9d1d9;
        }

        .empty-state {
            color: #8b949e;
            font-size: 0.95rem;
            text-align: center;
            padding: 24px 12px;
        }

        .directory-path {
            font-size: 0.85rem;
            color: #8b949e;
            word-break: break-all;
        }

        .offline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(13, 17, 23, 0.9);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
        }

        .offline-overlay.visible {
            display: flex;
        }

        .offline-message {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            color: #c9d1d9;
            max-width: 400px;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
        }

        .offline-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #30363d;
            border-top: 3px solid #58a6ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .offline-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0 0 8px;
            color: #ff7b72;
        }

        .offline-description {
            font-size: 0.9rem;
            color: #8b949e;
            margin: 0;
        }

        .terminal-panel {
            background: #0d1117;
            border-top: 1px solid #30363d;
            display: flex;
            flex-direction: column;
            height: 260px;
            min-height: 48px;
            max-height: 75vh;
            transition: height 0.15s ease;
            flex: 0 0 auto;
        }

        .terminal-panel.is-collapsed {
            height: 44px;
        }

        .terminal-panel.is-collapsed .terminal-resize-handle,
        .terminal-panel.is-collapsed .terminal-body {
            display: none;
        }

        .terminal-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            gap: 12px;
        }

        .terminal-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #c9d1d9;
        }

        .terminal-status {
            font-size: 0.8rem;
            color: #8b949e;
        }

        .terminal-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .terminal-actions button {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #30363d;
            background: #21262d;
            color: #c9d1d9;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
        }

        .terminal-actions button:hover:not(:disabled) {
            background: #2d333b;
        }

        .terminal-resize-handle {
            height: 6px;
            cursor: row-resize;
            background: linear-gradient(180deg, #30363d 0%, #21262d 100%);
            border-bottom: 1px solid #30363d;
        }

        .terminal-body {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #terminal-container {
            position: absolute;
            inset: 0;
        }
    </style>
</head>

<body>
    <div class="app-shell">
        <aside class="sidebar sidebar--toc" data-sidebar="toc">
            <div class="sidebar-collapsed-label" aria-hidden="true">ToC</div>
            <div class="sidebar-content">
                <div class="sidebar-header">
                    <h2 class="sidebar-title">Table of contents</h2>
                </div>
                <nav id="toc-list" class="toc-list" aria-label="Table of contents"></nav>
            </div>
        </aside>
        <div id="toc-splitter" class="splitter splitter--toc" role="separator" aria-orientation="vertical" tabindex="0"
            aria-label="Resize table of contents sidebar"></div>
        <section class="viewer">
            <header class="file-header">
                <div class="file-meta">
                    <h1 id="file-name">Markdown Viewer</h1>
                    <span id="status-message" class="status-message"></span>
                </div>
                <div class="file-actions">
                    <button id="edit-button" class="" title="Edit the current file"><i
                            class="fas fa-edit file-button-icon"></i></button>
                    <button id="preview-button" class=" hidden" title="Preview the pending changes"><i
                            class="fas fa-eye file-button-icon"></i></button>
                    <button id="save-button" class="hidden" title="Save your changes"><i
                            class="fas fa-save file-button-icon"></i></button>
                    <button id="cancel-button" class=" hidden" title="Cancel editing"><i
                            class="fas fa-times file-button-icon"></i></button>
                    <button id="download-button" title="Download the current file"><i
                            class="fas fa-download file-button-icon"></i></button>
                    <button id="delete-button" class="" title="Delete the current file"><i
                            class="fas fa-trash file-button-icon"></i></button>
                </div>
            </header>
            <div id="content" class="content-area"></div>
            <div id="editor-container" class="editor-container"></div>
        </section>
        <div id="file-splitter" class="splitter splitter--files" role="separator" aria-orientation="vertical"
            tabindex="0" aria-label="Resize file explorer sidebar"></div>
        <aside class="sidebar sidebar--files" data-sidebar="files">
            <div class="sidebar-collapsed-label" aria-hidden="true">Files</div>
            <div class="sidebar-content">
                <div class="sidebar-header">
                    <div class="sidebar-path" id="sidebar-path"></div>
                </div>
                <ul id="file-list" class="file-list" role="tree"></ul>
            </div>
        </aside>
    </div>

    <div id="offline-overlay" class="offline-overlay">
        <div class="offline-message">
            <div class="offline-spinner"></div>
            <h3 class="offline-title">Connection Lost</h3>
            <p class="offline-description">Reconnecting to the live view server...</p>
        </div>
    </div>

    <div id="terminal-panel" class="terminal-panel">
        <div class="terminal-toolbar">
            <div class="terminal-title"><i class="fas fa-terminal"></i><span>Terminal</span></div>
            <div class="terminal-actions">
                <span id="terminal-status" class="terminal-status" role="status" aria-live="polite">Disconnected</span>
                <button id="terminal-toggle" type="button" aria-expanded="true">Hide terminal</button>
            </div>
        </div>
        <div id="terminal-resize-handle" class="terminal-resize-handle" role="separator" aria-orientation="horizontal"
            tabindex="0" aria-label="Resize terminal panel"></div>
        <div class="terminal-body">
            <div id="terminal-container"></div>
        </div>
    </div>

    <script>
        window.__INITIAL_STATE__ = __INITIAL_STATE_JSON__;
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/14.1.2/marked.min.js"
        integrity="sha512-bXyBT2/sYjZg1D7ykDS6eJSE4DFDVPJHvbRAfdfYKr6IusrCz7wAmSm36vz9G8zMob25Rvqu90vft3JI71ygcQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/marked-base-url@1.1.7/lib/index.umd.js"
        integrity="sha512-vBt/Loem3LzFY7GzyW5LjD/RsH3CGU4ORjvDOiqEJDzPWCsCL6yKzCKid0oYSKyPAvH5j9RiwLs1L7QjKbgxEw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"
        integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js"
        integrity="sha512-gx05X612uoaolzJ5Ee/786b3th+qzAm90TOvRwZJwnE8yr0sHQG8eLxdR0/Hbqc2IFh2mWHzzXk79g3atNSwsQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"
        integrity="sha512-8Q6Y9XnTbOE+JNvjBQwJ2H8S+UV4uA6hiRykhdtIyDYZ2TprdNmWOUaKdGzOhyr4dCyk287OejbPvwl7lrfqrQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"
        integrity="sha512-MOCpqoRoisCTwJ8vQQiciZv0qcpROCidek3GTFS6KTk2+y7munJIlKCVkFCYY+p3ErYFXCjmFjnfTTRSC1OHWQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@excalidraw/excalidraw@0.17.4/dist/excalidraw.production.min.js"
        integrity="sha512-E2QYnMiPwJ0lKE9t8V7Ef/KcFgi/7LjV7LN9a9vavP2t1/mE9NfyANrt1imXfutaCK4jQo2ZhBPZbVCCqnvyYw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/vega@5.25.0/build/vega.min.js" crossorigin="anonymous"
        integrity="sha512-XX9YBZNtGu/Bz3d3zstE6vcEf4coHTGyxTwzU+0DNR7kHoD37krFcyWnqKTdzV6yWS9a5g3H3a71bM4ctzE1kA=="
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.15.0/build/vega-lite.min.js" crossorigin="anonymous"
        integrity="sha512-DFhjyQTRTao5MOf11Mxt3sft6Iamu6u7FlaarEW6VhIsN2flUUk30OZ5byOrxV3HCawL+YLalR2ZhKf2kBiLDw=="
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.22.2/build/vega-embed.min.js" crossorigin="anonymous"
        integrity="sha512-XGkG4fTLMPA3Lp9FUGv7MFNvzpAzC/QgC//cOSxjfhmj8fZjF8iyqn9rgXjwHiY1xqWFzn+BnH8R0oGClEIPvw=="
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"
        integrity="sha512-OeZ4Yrb/W7d2W4rAMOO0HQ9Ro/aWLtpW9BUSR2UOWnSV2hprXLkkYnnCGc9NeLUxxE4ZG7zN16UuT1Elqq8Opg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"
        integrity="sha512-DmMao0nRIbyDjbaHc8fNd3kxGsZj9PCU6Iu/CeidLQT9Py8nYVA5n0PqXYmvqNdU+lCiTHOM/4E7bM/G8BttJg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js" crossorigin="anonymous"
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js" crossorigin="anonymous"
        referrerpolicy="no-referrer" defer></script>
    <script defer>
        (function () {
            const state = window.__INITIAL_STATE__ || {};
            const content = document.getElementById('content');
            const fileName = document.getElementById('file-name');
            const sidebarPath = document.getElementById('sidebar-path');
            const statusMessage = document.getElementById('status-message');
            const fileList = document.getElementById('file-list');
            const downloadButton = document.getElementById('download-button');
            const deleteButton = document.getElementById('delete-button');
            const editButton = document.getElementById('edit-button');
            const previewButton = document.getElementById('preview-button');
            const saveButton = document.getElementById('save-button');
            const cancelButton = document.getElementById('cancel-button');
            const editorContainer = document.getElementById('editor-container');
            const offlineOverlay = document.getElementById('offline-overlay');
            const tocList = document.getElementById('toc-list');
            const tocSidebar = document.querySelector('.sidebar--toc');
            const fileSidebar = document.querySelector('.sidebar--files');
            const tocSplitter = document.getElementById('toc-splitter');
            const fileSplitter = document.getElementById('file-splitter');
            const rootElement = document.documentElement;
            const collapsedSidebarWidth = getCssNumber('--sidebar-collapsed-width', 18);
            const terminalPanel = document.getElementById('terminal-panel');
            const terminalContainer = document.getElementById('terminal-container');
            const terminalToggleButton = document.getElementById('terminal-toggle');
            const terminalStatusText = document.getElementById('terminal-status');
            const terminalResizeHandle = document.getElementById('terminal-resize-handle');
            const terminalStorageKey = 'terminalPanelHeight';

            const initialIndex = normaliseFileIndex({
                filesValue: state.files,
                treeValue: state.fileTree,
            });
            let currentFile = state.selectedFile || null;
            let files = initialIndex.files;
            let fileTree = initialIndex.tree;
            let websocket = null;
            let reconnectTimer = null;
            let isEditing = false;
            let isPreviewing = false;
            let editorInstance = null;
            let draftContent = '';
            let currentContent = typeof state.content === 'string' ? state.content : '';

            const originalPathArgument = state.pathArgument || '';
            let resolvedRootPath = state.rootPath || '';
            const initialFileFromLocation = fileFromSearch(window.location.search);
            const textEncoder = new TextEncoder();
            const textDecoder = new TextDecoder();
            let markedConfigured = false;
            let mermaidInitAttempted = false;
            let mermaidRetryTimer = null;
            let vegaRetryTimer = null;
            let excalidrawRetryTimer = null;
            let mermaidIdCounter = 0;
            let vegaIdCounter = 0;
            let excalidrawIdCounter = 0;
            const excalidrawRoots = new Map();
            let excalidrawResizeHandlerAttached = false;
            let excalidrawFitFailureLogged = false;
            let librariesReadyPromise = null;
            let pendingMarkdown = null;
            let relativeLinksEnabled = false;
            let relativeLinkBasePath = '';
            let relativeLinkBaseWalker = null;
            let relativeLinkExtensionRegistered = false;
            const relativeLinkDummyOrigin = 'http://__dummy__/';
            const relativeLinkSchemePattern = /^[a-zA-Z][\w+.-]*:/;
            const relativeLinkProtocolRelativePattern = /^\/\//;
            const expandedDirectories = new Set();
            const knownDirectories = new Set();
            const sidebarControllers = { toc: null, files: null };
            let activeHeadingCollection = null;
            let documentSlugCounts = null;
            let terminalInstance = null;
            let terminalFitAddon = null;
            let terminalSocket = null;
            let terminalReconnectTimer = null;
            let terminalLibraryRetryTimer = null;
            let terminalCollapsed = false;
            let terminalHeight = null;
            let pendingTerminalFitFrame = null;
            const terminalDecoder = new TextDecoder();
            let terminalLastStatusMessage = '';

            function normaliseFileIndex({ filesValue, treeValue }) {
                let flat = [];
                let tree = [];

                if (Array.isArray(filesValue)) {
                    flat = filesValue;
                } else if (filesValue && Array.isArray(filesValue.files)) {
                    flat = filesValue.files;
                    if (Array.isArray(filesValue.tree)) {
                        tree = filesValue.tree;
                    }
                }

                if (!tree.length && Array.isArray(treeValue)) {
                    tree = treeValue;
                }

                if (tree.length && !flat.length) {
                    flat = flattenTree(tree);
                }

                if (!tree.length && flat.length) {
                    tree = buildTreeFromFlatList(flat);
                }

                return { files: flat, tree };
            }

            function flattenTree(nodes) {
                const result = [];
                if (!Array.isArray(nodes)) {
                    return result;
                }

                const stack = [...nodes];
                while (stack.length) {
                    const node = stack.shift();
                    if (!node || typeof node !== 'object') {
                        continue;
                    }

                    if (node.type === 'file') {
                        result.push({
                            name: node.name,
                            relativePath: node.relativePath,
                            size: node.size,
                            updated: node.updated,
                        });
                        continue;
                    }

                    if (node.type === 'directory' && Array.isArray(node.children)) {
                        stack.unshift(...node.children);
                    }
                }

                return result;
            }

            function buildTreeFromFlatList(flatList) {
                if (!Array.isArray(flatList) || !flatList.length) {
                    return [];
                }

                const root = [];
                const directoryMap = new Map();
                directoryMap.set('', root);

                function ensureDirectory(path, name) {
                    if (directoryMap.has(path)) {
                        return directoryMap.get(path);
                    }

                    const parentPath = path.includes('/') ? path.slice(0, path.lastIndexOf('/')) : '';
                    const parentChildren = directoryMap.get(parentPath) || root;
                    const node = {
                        type: 'directory',
                        name,
                        relativePath: path,
                        children: [],
                    };
                    parentChildren.push(node);
                    directoryMap.set(path, node.children);
                    return node.children;
                }

                flatList.forEach((file) => {
                    if (!file || typeof file.relativePath !== 'string') {
                        return;
                    }

                    const segments = file.relativePath.split('/');
                    const fileName = segments.pop();
                    let currentPath = '';
                    segments.forEach((segment) => {
                        if (!segment) {
                            return;
                        }
                        currentPath = currentPath ? `${currentPath}/${segment}` : segment;
                        ensureDirectory(currentPath, segment);
                    });

                    const parentPath = segments.join('/');
                    const parentChildren = directoryMap.get(parentPath) || root;
                    parentChildren.push({
                        type: 'file',
                        name: fileName,
                        relativePath: file.relativePath,
                        size: file.size,
                        updated: file.updated,
                    });
                });

                sortTree(root);
                return root;
            }

            function sortTree(nodes) {
                if (!Array.isArray(nodes)) {
                    return;
                }
                nodes.sort((a, b) => {
                    if (a.type === b.type) {
                        return String(a.name || '').localeCompare(String(b.name || ''));
                    }
                    return a.type === 'directory' ? -1 : 1;
                });
                nodes.forEach((node) => {
                    if (node.type === 'directory') {
                        sortTree(node.children);
                    }
                });
            }

            function initialiseSidebars() {
                sidebarControllers.toc = setupSidebarController({
                    sidebar: tocSidebar,
                    splitter: tocSplitter,
                    storageKey: 'liveview.tocSidebarWidth',
                    minWidth: 180,
                    maxWidth: 420,
                    widthVar: '--toc-sidebar-width',
                    currentVar: '--toc-sidebar-current-width',
                    dragDirection: 1,
                    keyboardDirections: {
                        ArrowLeft: -1,
                        ArrowRight: 1,
                    },
                });

                sidebarControllers.files = setupSidebarController({
                    sidebar: fileSidebar,
                    splitter: fileSplitter,
                    storageKey: 'liveview.fileSidebarWidth',
                    legacyKeys: ['liveview.sidebarWidth'],
                    minWidth: 220,
                    maxWidth: 520,
                    widthVar: '--file-sidebar-width',
                    currentVar: '--file-sidebar-current-width',
                    dragDirection: -1,
                    keyboardDirections: {
                        ArrowLeft: 1,
                        ArrowRight: -1,
                    },
                });
            }

            function setupSidebarController(config) {
                if (!config || !config.sidebar || !config.splitter) {
                    return null;
                }

                const { sidebar, splitter } = config;
                const storageKeys = [config.storageKey].concat(Array.isArray(config.legacyKeys) ? config.legacyKeys : []);
                const dragDirection = typeof config.dragDirection === 'number' ? config.dragDirection : 1;
                const keyboardDirections = config.keyboardDirections || {};
                const responsiveQuery = window.matchMedia('(max-width: 980px)');
                let collapseTimer = null;

                function clampWidth(value) {
                    const numeric = Number.parseFloat(value);
                    if (!Number.isFinite(numeric)) {
                        return config.minWidth;
                    }
                    return Math.min(config.maxWidth, Math.max(config.minWidth, numeric));
                }

                function loadStoredWidth() {
                    for (let index = 0; index < storageKeys.length; index += 1) {
                        const key = storageKeys[index];
                        if (!key) {
                            continue;
                        }
                        try {
                            const raw = window.localStorage.getItem(key);
                            if (raw !== null) {
                                const parsed = Number.parseFloat(raw);
                                if (Number.isFinite(parsed)) {
                                    return clampWidth(parsed);
                                }
                            }
                        } catch (error) {
                            console.warn('Unable to read stored sidebar width', error);
                            break;
                        }
                    }

                    const fallbackWidth = getCssNumber(config.widthVar, config.minWidth);
                    return clampWidth(fallbackWidth);
                }

                function isCompactLayout() {
                    return responsiveQuery.matches;
                }

                function cancelScheduledCollapse() {
                    if (collapseTimer !== null) {
                        window.clearTimeout(collapseTimer);
                        collapseTimer = null;
                    }
                }

                function scheduleCollapse(controller) {
                    cancelScheduledCollapse();
                    collapseTimer = window.setTimeout(() => {
                        collapseTimer = null;
                        controller.collapseIfInactive();
                    }, 200);
                }

                const controller = {
                    collapsed: true,
                    width: clampWidth(loadStoredWidth()),
                    setWidth(newWidth) {
                        const clamped = clampWidth(newWidth);
                        controller.width = clamped;
                        rootElement.style.setProperty(config.widthVar, `${clamped}px`);
                        if (!controller.collapsed || isCompactLayout()) {
                            rootElement.style.setProperty(config.currentVar, `${clamped}px`);
                        }
                        return clamped;
                    },
                    persistWidth() {
                        try {
                            window.localStorage.setItem(config.storageKey, String(controller.width));
                        } catch (error) {
                            console.warn('Unable to persist sidebar width', error);
                        }
                    },
                    setCollapsed(collapsed) {
                        controller.collapsed = Boolean(collapsed);
                        const shouldCollapse = controller.collapsed && !isCompactLayout();
                        const targetWidth = shouldCollapse ? collapsedSidebarWidth : controller.width;
                        sidebar.classList.toggle('is-expanded', !shouldCollapse);
                        rootElement.style.setProperty(config.currentVar, `${targetWidth}px`);
                        if (!shouldCollapse) {
                            rootElement.style.setProperty(config.widthVar, `${controller.width}px`);
                        }
                    },
                    ensureExpanded() {
                        cancelScheduledCollapse();
                        controller.setCollapsed(false);
                    },
                    collapseIfInactive() {
                        if (isCompactLayout()) {
                            controller.setCollapsed(false);
                            return;
                        }

                        if (!sidebar.matches(':hover') && !sidebar.matches(':focus-within')) {
                            controller.setCollapsed(true);
                        }
                    },
                };

                controller.setWidth(controller.width);
                controller.setCollapsed(true);

                const handlePointerDown = (event) => {
                    if (event.button !== 0 || isCompactLayout()) {
                        return;
                    }

                    event.preventDefault();
                    controller.ensureExpanded();
                    splitter.classList.add('dragging');
                    const startX = event.clientX;
                    const startWidth = sidebar.getBoundingClientRect().width;

                    const handleMove = (moveEvent) => {
                        const delta = moveEvent.clientX - startX;
                        controller.setWidth(startWidth + delta * dragDirection);
                    };

                    const handleStop = () => {
                        splitter.classList.remove('dragging');
                        document.removeEventListener('pointermove', handleMove);
                        document.removeEventListener('pointerup', handleStop);
                        controller.persistWidth();
                        controller.collapseIfInactive();
                    };

                    document.addEventListener('pointermove', handleMove);
                    document.addEventListener('pointerup', handleStop);
                };

                const handleKeyDown = (event) => {
                    const direction = keyboardDirections[event.key];
                    if (!direction) {
                        return;
                    }

                    event.preventDefault();
                    const step = event.shiftKey ? 48 : 16;
                    controller.ensureExpanded();
                    controller.setWidth(controller.width + direction * step);
                    controller.persistWidth();
                };

                const handleMouseEnter = () => {
                    controller.ensureExpanded();
                };

                const handleMouseLeave = () => {
                    scheduleCollapse(controller);
                };

                const handleFocusIn = () => {
                    controller.ensureExpanded();
                };

                const handleFocusOut = () => {
                    scheduleCollapse(controller);
                };

                const handleResponsiveChange = () => {
                    if (isCompactLayout()) {
                        cancelScheduledCollapse();
                        controller.setCollapsed(false);
                    } else {
                        controller.collapseIfInactive();
                    }
                };

                splitter.addEventListener('pointerdown', handlePointerDown);
                splitter.addEventListener('keydown', handleKeyDown);
                splitter.addEventListener('mouseenter', handleMouseEnter);
                splitter.addEventListener('mouseleave', handleMouseLeave);
                splitter.addEventListener('focusin', handleFocusIn);
                splitter.addEventListener('focusout', handleFocusOut);
                sidebar.addEventListener('mouseenter', handleMouseEnter);
                sidebar.addEventListener('pointerdown', handleMouseEnter);
                sidebar.addEventListener('mouseleave', handleMouseLeave);
                sidebar.addEventListener('focusin', handleFocusIn);
                sidebar.addEventListener('focusout', handleFocusOut);

                if (typeof responsiveQuery.addEventListener === 'function') {
                    responsiveQuery.addEventListener('change', handleResponsiveChange);
                } else if (typeof responsiveQuery.addListener === 'function') {
                    responsiveQuery.addListener(handleResponsiveChange);
                }

                handleResponsiveChange();

                return controller;
            }

            function updateRelativeLinkBase(filePath) {
                if (typeof filePath !== 'string' || filePath.length === 0) {
                    relativeLinksEnabled = false;
                    relativeLinkBasePath = '';
                    relativeLinkBaseWalker = null;
                    return;
                }

                relativeLinksEnabled = true;
                const lastSlashIndex = filePath.lastIndexOf('/');
                relativeLinkBasePath = lastSlashIndex === -1 ? '' : filePath.slice(0, lastSlashIndex + 1);

                if (typeof markedBaseUrl !== 'undefined' && markedBaseUrl && typeof markedBaseUrl.baseUrl === 'function') {
                    const baseCandidate = relativeLinkBasePath || './';
                    try {
                        relativeLinkBaseWalker = markedBaseUrl.baseUrl(baseCandidate);
                    } catch (error) {
                        console.warn('Failed to initialise marked-base-url', error);
                        relativeLinkBaseWalker = null;
                    }
                } else {
                    relativeLinkBaseWalker = null;
                }
            }

            function decodePathSegments(path) {
                if (!path) {
                    return '';
                }
                return path
                    .split('/')
                    .map((segment) => {
                        try {
                            return decodeURIComponent(segment);
                        } catch {
                            return segment;
                        }
                    })
                    .join('/');
            }

            function encodePathSegments(path) {
                if (!path) {
                    return '';
                }
                return path
                    .split('/')
                    .map((segment) => encodeURIComponent(segment))
                    .join('/');
            }

            function fallbackResolveRelativeHref(href) {
                try {
                    const baseReference = relativeLinkBasePath ? relativeLinkBasePath : '.';
                    const baseUrl = new URL(baseReference, relativeLinkDummyOrigin);
                    const resolvedUrl = new URL(href, baseUrl);
                    const normalisedPath = resolvedUrl.pathname.replace(/^\/+/u, '');
                    const decodedPath = decodePathSegments(normalisedPath);
                    return `${decodedPath}${resolvedUrl.search}${resolvedUrl.hash}`;
                } catch (error) {
                    console.warn('Relative link fallback failed', error);
                    return href;
                }
            }

            function splitResolvedHref(resolvedHref) {
                if (typeof resolvedHref !== 'string' || resolvedHref.length === 0) {
                    return { filePath: '', search: '', hash: '' };
                }

                let working = resolvedHref;
                let hash = '';
                const hashIndex = working.indexOf('#');
                if (hashIndex !== -1) {
                    hash = working.slice(hashIndex);
                    working = working.slice(0, hashIndex);
                }

                let search = '';
                const searchIndex = working.indexOf('?');
                if (searchIndex !== -1) {
                    search = working.slice(searchIndex);
                    working = working.slice(0, searchIndex);
                }

                const cleaned = working.replace(/^\.\//, '').replace(/^\/+/u, '');
                const filePath = decodePathSegments(cleaned);
                return { filePath, search, hash };
            }

            function transformRelativeAsset(rawHref, tokenType) {
                if (!relativeLinksEnabled || typeof rawHref !== 'string') {
                    return null;
                }

                const trimmedHref = rawHref.trim();
                if (
                    !trimmedHref ||
                    trimmedHref.startsWith('#') ||
                    relativeLinkProtocolRelativePattern.test(trimmedHref) ||
                    relativeLinkSchemePattern.test(trimmedHref) ||
                    trimmedHref.startsWith('/')
                ) {
                    return null;
                }

                let resolvedHref = trimmedHref;
                const walker = relativeLinkBaseWalker;

                if (walker && typeof walker.walkTokens === 'function') {
                    const tempToken = { type: tokenType, href: trimmedHref };
                    try {
                        walker.walkTokens(tempToken);
                        resolvedHref = tempToken.href;
                    } catch (error) {
                        console.warn('marked-base-url resolution failed', error);
                        resolvedHref = fallbackResolveRelativeHref(trimmedHref);
                    }
                } else {
                    resolvedHref = fallbackResolveRelativeHref(trimmedHref);
                }

                const parts = splitResolvedHref(resolvedHref);
                if (!parts.filePath) {
                    return null;
                }

                if (tokenType === 'image') {
                    return {
                        assetHref: `${encodePathSegments(parts.filePath)}${parts.search}${parts.hash}`,
                    };
                }

                return {
                    fileTarget: `${parts.filePath}${parts.search}`,
                    hash: parts.hash,
                };
            }

            const relativeLinkExtension = {
                walkTokens(token) {
                    if (!token || typeof token.href !== 'string') {
                        return;
                    }

                    if (token.type === 'image') {
                        const asset = transformRelativeAsset(token.href, 'image');
                        if (asset && asset.assetHref) {
                            token.href = asset.assetHref;
                        }
                        return;
                    }

                    if (token.type !== 'link') {
                        return;
                    }

                    const result = transformRelativeAsset(token.href, 'link');
                    if (!result || !result.fileTarget) {
                        return;
                    }

                    const basePathname = typeof window !== 'undefined' && window.location ? window.location.pathname : '';
                    const query = buildQuery({ file: result.fileTarget });
                    token.href = `${basePathname}${query}${result.hash || ''}`;
                },
            };

            function getCssNumber(variableName, fallback) {
                if (typeof variableName !== 'string' || !variableName) {
                    return typeof fallback === 'number' ? fallback : 0;
                }

                try {
                    const computed = getComputedStyle(rootElement).getPropertyValue(variableName);
                    const parsed = Number.parseFloat(computed);
                    if (Number.isFinite(parsed)) {
                        return parsed;
                    }
                } catch (error) {
                    console.warn('Failed to read CSS variable', variableName, error);
                }

                return typeof fallback === 'number' ? fallback : 0;
            }

            function configureMarked() {
                if (typeof marked === 'undefined' || markedConfigured) {
                    return;
                }

                marked.use({
                    walkTokens(token) {
                        if (!token || token.type !== 'code') {
                            return;
                        }

                        const language = typeof token.lang === 'string' ? token.lang.toLowerCase() : '';
                        const source = token.text || token.raw || '';

                        if (language.includes('mermaid')) {
                            const id = `mermaid-diagram-${mermaidIdCounter++}`;
                            const encodedSource = encodeMermaidSource(source);
                            const mermaidHtml = `<div class="mermaid" id="${id}" data-mermaid-source="${encodedSource}"></div>`;
                            token.type = 'html';
                            token.raw = mermaidHtml;
                            token.text = mermaidHtml;
                            return;
                        }

                        if (language.includes('vega-lite') || language === 'vega') {
                            const id = `vega-diagram-${vegaIdCounter++}`;
                            const encodedSource = encodeVegaSource(source);
                            const vegaHtml = `<div class="vega-diagram" id="${id}" data-vega-source="${encodedSource}"></div>`;
                            token.type = 'html';
                            token.raw = vegaHtml;
                            token.text = vegaHtml;
                            return;
                        }

                        if (language.includes('excalidraw')) {
                            const id = `excalidraw-diagram-${excalidrawIdCounter++}`;
                            const encodedSource = encodeExcalidrawSource(source);
                            const excalidrawHtml = `<div class="excalidraw-diagram" id="${id}" data-excalidraw-source="${encodedSource}"></div>`;
                            token.type = 'html';
                            token.raw = excalidrawHtml;
                            token.text = excalidrawHtml;
                        }
                    },
                });

                marked.use({
                    headerIds: true,
                    mangle: false,
                    renderer: {
                        heading({ text, depth, raw }) {
                            const headingLevel = Math.min(Math.max(depth || 1, 1), 6);

                            // Create slug from the raw text or the rendered text
                            const sourceText = typeof raw === 'string' ? raw : text;
                            const slug = createSlug(sourceText);
                            const plainText = normaliseHeadingText(text, raw);
                            const ariaSource = plainText || (typeof raw === 'string' ? raw : 'heading');
                            const ariaLabel = escapeHtml(`Link to section ${ariaSource}`);

                            if (Array.isArray(activeHeadingCollection)) {
                                activeHeadingCollection.push({
                                    level: headingLevel,
                                    text: plainText || ariaSource,
                                    slug,
                                });
                            }

                            return `<h${headingLevel} id="${slug}">${text}<a class="heading-anchor" href="#${slug}" aria-label="${ariaLabel}"></a></h${headingLevel}>`;
                        },
                    },
                });

                marked.setOptions({
                    breaks: true,
                    gfm: true,
                    highlight(code, language) {
                        if (typeof hljs === 'undefined') {
                            return code;
                        }
                        try {
                            if (language && hljs.getLanguage(language)) {
                                return hljs.highlight(code, { language }).value;
                            }
                            return hljs.highlightAuto(code).value;
                        } catch (err) {
                            console.warn('Highlight.js failed to render a block', err);
                            return code;
                        }
                    },
                });

                if (!relativeLinkExtensionRegistered) {
                    marked.use(relativeLinkExtension);
                    relativeLinkExtensionRegistered = true;
                }

                markedConfigured = true;
            }

            function normaliseHeadingText(rendered, raw) {
                if (typeof rendered === 'string' && rendered.trim()) {
                    const temp = document.createElement('div');
                    temp.innerHTML = rendered;
                    const textContent = (temp.textContent || temp.innerText || '').trim();
                    if (textContent) {
                        return textContent;
                    }
                }

                if (typeof raw === 'string') {
                    const trimmed = raw.trim();
                    if (trimmed) {
                        return trimmed;
                    }
                }

                return '';
            }

            function escapeHtml(value) {
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function createSlug(text) {
                if (!text) return '';

                // Remove HTML tags first
                const temp = document.createElement('div');
                temp.innerHTML = text;
                const cleanText = temp.textContent || temp.innerText || text;

                // Create slug: lowercase, remove special chars, replace spaces with hyphens
                let slug = cleanText
                    .toLowerCase()
                    .trim()
                    .replace(/[^\w\s-]/g, '') // Remove special characters except word chars, spaces, and hyphens
                    .replace(/\s+/g, '-')     // Replace spaces with hyphens
                    .replace(/-+/g, '-')      // Replace multiple hyphens with single hyphen
                    .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens

                if (!slug) {
                    slug = 'heading';
                }

                // Ensure uniqueness within the document
                if (documentSlugCounts && documentSlugCounts.has(slug)) {
                    const count = documentSlugCounts.get(slug) + 1;
                    documentSlugCounts.set(slug, count);
                    slug = `${slug}-${count}`;
                } else if (documentSlugCounts) {
                    documentSlugCounts.set(slug, 0);
                }

                return slug;
            }

            function encodeDiagramSource(code) {
                if (!code) {
                    return '';
                }
                const bytes = textEncoder.encode(code);
                let binary = '';
                bytes.forEach((byte) => {
                    binary += String.fromCharCode(byte);
                });
                return btoa(binary);
            }

            function decodeDiagramSource(encoded, label = 'diagram') {
                if (!encoded) {
                    return '';
                }
                try {
                    const bytes = Uint8Array.from(atob(encoded), (char) => char.charCodeAt(0));
                    return textDecoder.decode(bytes);
                } catch (error) {
                    console.warn(`Failed to decode ${label} source`, error);
                    return '';
                }
            }

            function encodeMermaidSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeMermaidSource(encoded) {
                return decodeDiagramSource(encoded, 'Mermaid');
            }

            function encodeVegaSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeVegaSource(encoded) {
                return decodeDiagramSource(encoded, 'Vega');
            }

            function encodeExcalidrawSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeExcalidrawSource(encoded) {
                return decodeDiagramSource(encoded, 'Excalidraw');
            }

            function createExcalidrawViewerUiOptions() {
                return {
                    canvasActions: {
                        changeViewBackgroundColor: false,
                        clearCanvas: false,
                        export: false,
                        loadScene: false,
                        saveAsImage: false,
                        saveScene: false,
                        saveToActiveFile: false,
                        toggleTheme: false,
                        toggleShortcuts: false,
                        zoomIn: false,
                        zoomOut: false,
                        zoomToFit: false,
                        resetZoom: false,
                        pan: false,
                        viewMode: false,
                        zenMode: false,
                        gridMode: false,
                        stats: false,
                    },
                };
            }

            function waitForCoreLibraries(maxRetries = 80, interval = 100) {
                if (librariesReadyPromise) {
                    return librariesReadyPromise;
                }

                librariesReadyPromise = new Promise((resolve) => {
                    let attempts = 0;
                    const check = () => {
                        if (typeof marked !== 'undefined') {
                            resolve();
                            return;
                        }

                        if (attempts++ >= maxRetries) {
                            resolve();
                            return;
                        }

                        window.setTimeout(check, interval);
                    };

                    check();
                });

                return librariesReadyPromise;
            }

            const DIAGRAM_ICONS = {
                Mermaid: '📊',
                Vega: '📈',
                Excalidraw: '✏️',
            };

            function showDiagramStatus(element, type, message, source, variant) {
                const icon = DIAGRAM_ICONS[type] || 'ℹ️';
                const emphasised = variant === 'error' ? `<strong>${escapeHtml(message)}</strong>` : escapeHtml(message);
                const sourceMarkup = source ? `<pre>${escapeHtml(source)}</pre>` : '';
                element.innerHTML = `
                    <div class="diagram-loading">
                        ${icon} <strong>${escapeHtml(type)}</strong><br>
                        ${emphasised}
                        ${sourceMarkup}
                    </div>
                `;
            }

            function showDiagramLoading(element, type, source) {
                showDiagramStatus(element, type, `${type} renderer loading…`, source, 'loading');
            }

            function showDiagramError(element, type, message, source) {
                showDiagramStatus(element, type, `Error: ${message}`, source, 'error');
            }

            function cleanupExcalidrawRoots() {
                excalidrawRoots.forEach((record) => {
                    try {
                        if (record && typeof record.unmount === 'function') {
                            record.unmount();
                        } else if (record && record.root && typeof record.root.unmount === 'function') {
                            record.root.unmount();
                        }
                    } catch (error) {
                        console.warn('Failed to unmount Excalidraw root', error);
                    }
                });
                excalidrawRoots.clear();
            }

            function scheduleMermaidRetry() {
                if (mermaidRetryTimer) {
                    return;
                }
                mermaidRetryTimer = window.setTimeout(() => {
                    mermaidRetryTimer = null;
                    renderMermaidDiagrams();
                }, 400);
            }

            function scheduleVegaRetry() {
                if (vegaRetryTimer) {
                    return;
                }
                vegaRetryTimer = window.setTimeout(() => {
                    vegaRetryTimer = null;
                    renderVegaVisualizations();
                }, 400);
            }

            function scheduleExcalidrawRetry() {
                if (excalidrawRetryTimer) {
                    return;
                }
                excalidrawRetryTimer = window.setTimeout(() => {
                    excalidrawRetryTimer = null;
                    renderExcalidrawDiagrams();
                }, 400);
            }

            function handleExcalidrawResize() {
                excalidrawRoots.forEach((record) => {
                    if (record && record.api) {
                        fitExcalidrawToViewport(record.api);
                    }
                });
            }

            function ensureExcalidrawResizeHandler() {
                if (excalidrawResizeHandlerAttached) {
                    return;
                }
                if (typeof window === 'undefined' || typeof window.addEventListener !== 'function') {
                    return;
                }
                window.addEventListener('resize', handleExcalidrawResize);
                excalidrawResizeHandlerAttached = true;
            }

            function fitExcalidrawToViewport(api) {
                if (!api || typeof api.getSceneElements !== 'function' || typeof api.scrollToContent !== 'function') {
                    return;
                }

                let elements;
                try {
                    elements = api.getSceneElements();
                } catch (error) {
                    console.warn('Failed to read Excalidraw scene elements', error);
                    return;
                }

                if (!Array.isArray(elements) || !elements.length) {
                    return;
                }

                const visibleElements = elements.filter((item) => item && !item.isDeleted);
                if (!visibleElements.length) {
                    return;
                }

                const executeFit = () => {
                    try {
                        api.scrollToContent(visibleElements, { fitToViewport: true, animate: false });
                    } catch (error) {
                        if (!excalidrawFitFailureLogged) {
                            console.warn('Failed to fit Excalidraw content', error);
                            excalidrawFitFailureLogged = true;
                        }
                    }
                };

                if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
                    window.requestAnimationFrame(executeFit);
                } else {
                    executeFit();
                }

                if (typeof window !== 'undefined' && typeof window.setTimeout === 'function') {
                    window.setTimeout(executeFit, 150);
                }
            }

            function renderMermaidDiagrams() {
                const diagrams = content.querySelectorAll('.mermaid[data-mermaid-source]');
                if (!diagrams.length) {
                    return;
                }

                if (typeof mermaid === 'undefined' || typeof mermaid.render !== 'function') {
                    diagrams.forEach((element) => {
                        const source = decodeMermaidSource(element.dataset.mermaidSource);
                        showDiagramLoading(element, 'Mermaid', source);
                    });
                    scheduleMermaidRetry();
                    return;
                }

                if (!mermaidInitAttempted) {
                    try {
                        mermaid.initialize({
                            startOnLoad: false,
                            theme: 'dark',
                            securityLevel: 'loose',
                        });
                    } catch (error) {
                        console.warn('Mermaid initialization issue', error);
                    }
                    mermaidInitAttempted = true;
                }

                diagrams.forEach((element, index) => {
                    const source = decodeMermaidSource(element.dataset.mermaidSource);
                    if (!source.trim()) {
                        showDiagramError(element, 'Mermaid', 'Diagram source is empty', source);
                        return;
                    }

                    const renderId = `${element.id || 'mermaid-diagram'}-${index}`;
                    mermaid
                        .render(renderId, source)
                        .then(({ svg }) => {
                            element.innerHTML = svg;
                        })
                        .catch((error) => {
                            console.error('Mermaid rendering error', error);
                            showDiagramError(element, 'Mermaid', error.message, source);
                        });
                });
            }

            function renderVegaVisualizations() {
                const diagrams = content.querySelectorAll('.vega-diagram[data-vega-source]');
                if (!diagrams.length) {
                    return;
                }

                if (typeof vegaEmbed === 'undefined') {
                    diagrams.forEach((element) => {
                        const source = decodeVegaSource(element.dataset.vegaSource);
                        showDiagramLoading(element, 'Vega', source);
                    });
                    scheduleVegaRetry();
                    return;
                }

                diagrams.forEach((element) => {
                    const source = decodeVegaSource(element.dataset.vegaSource);
                    if (!source.trim()) {
                        showDiagramError(element, 'Vega', 'Specification is empty', source);
                        return;
                    }

                    let spec;
                    try {
                        spec = JSON.parse(source);
                    } catch (error) {
                        console.error('Vega parsing error', error);
                        showDiagramError(element, 'Vega', 'Invalid Vega/Vega-Lite specification', source);
                        return;
                    }

                    element.innerHTML = '';
                    vegaEmbed(element, spec, { actions: false, renderer: 'canvas', theme: 'dark' }).catch((error) => {
                        console.error('Vega rendering error', error);
                        showDiagramError(element, 'Vega', error.message, source);
                    });
                });
            }

            function renderExcalidrawDiagrams() {
                const diagrams = content.querySelectorAll('.excalidraw-diagram[data-excalidraw-source]');
                if (!diagrams.length) {
                    return;
                }

                if (
                    !window.React ||
                    !window.ReactDOM ||
                    !window.ExcalidrawLib ||
                    !window.ExcalidrawLib.Excalidraw
                ) {
                    diagrams.forEach((element) => {
                        const source = decodeExcalidrawSource(element.dataset.excalidrawSource);
                        showDiagramLoading(element, 'Excalidraw', source);
                    });
                    scheduleExcalidrawRetry();
                    return;
                }

                diagrams.forEach((element) => {
                    const source = decodeExcalidrawSource(element.dataset.excalidrawSource);
                    if (!source.trim()) {
                        showDiagramError(element, 'Excalidraw', 'Scene data is empty', source);
                        return;
                    }

                    let sceneData;
                    try {
                        sceneData = JSON.parse(source);
                    } catch (error) {
                        console.error('Excalidraw parsing error', error);
                        showDiagramError(element, 'Excalidraw', 'Invalid scene JSON', source);
                        return;
                    }

                    const desiredBackground = 'transparent';
                    sceneData = {
                        ...sceneData,
                        appState: {
                            ...(sceneData && typeof sceneData === 'object' && sceneData.appState
                                ? sceneData.appState
                                : {}),
                            viewBackgroundColor: desiredBackground,
                        },
                    };

                    const existingRoot = excalidrawRoots.get(element);
                    if (existingRoot && typeof existingRoot.unmount === 'function') {
                        try {
                            existingRoot.unmount();
                        } catch (error) {
                            console.warn('Failed to unmount previous Excalidraw root', error);
                        }
                    }
                    excalidrawRoots.delete(element);

                    element.innerHTML = '';
                    const wrapper = document.createElement('div');
                    wrapper.className = 'excalidraw-wrapper';
                    wrapper.tabIndex = -1;
                    element.appendChild(wrapper);

                    const record = {
                        root: null,
                        api: null,
                        wrapper,
                        unmount() {
                            record.api = null;
                            if (record.root && typeof record.root.unmount === 'function') {
                                record.root.unmount();
                            } else if (
                                typeof window.ReactDOM !== 'undefined' &&
                                typeof window.ReactDOM.unmountComponentAtNode === 'function'
                            ) {
                                try {
                                    window.ReactDOM.unmountComponentAtNode(wrapper);
                                } catch (error) {
                                    console.warn('Failed to unmount Excalidraw instance', error);
                                }
                            }
                        },
                    };

                    try {
                        const viewerUiOptions = createExcalidrawViewerUiOptions();
                        const excalidrawElement = window.React.createElement(window.ExcalidrawLib.Excalidraw, {
                            initialData: sceneData,
                            viewModeEnabled: true,
                            zenModeEnabled: false,
                            gridModeEnabled: false,
                            theme: 'dark',
                            autoFocus: false,
                            UIOptions: viewerUiOptions,
                            handleKeyboardEvent: () => false,
                            ref: (api) => {
                                record.api = api || null;
                                if (api) {
                                    excalidrawFitFailureLogged = false;
                                    ensureExcalidrawResizeHandler();
                                    fitExcalidrawToViewport(api);
                                    if (typeof window !== 'undefined' && typeof window.setTimeout === 'function') {
                                        window.setTimeout(() => fitExcalidrawToViewport(api), 250);
                                    }
                                }
                            },
                        });

                        let root;
                        if (typeof window.ReactDOM.createRoot === 'function') {
                            root = window.ReactDOM.createRoot(wrapper);
                            root.render(excalidrawElement);
                        } else if (typeof window.ReactDOM.render === 'function') {
                            window.ReactDOM.render(excalidrawElement, wrapper);
                            root = {
                                unmount() {
                                    if (typeof window.ReactDOM.unmountComponentAtNode === 'function') {
                                        window.ReactDOM.unmountComponentAtNode(wrapper);
                                    }
                                },
                            };
                        } else {
                            throw new Error('ReactDOM renderer is unavailable');
                        }

                        record.root = root;
                        excalidrawRoots.set(element, record);
                    } catch (error) {
                        record.api = null;
                        console.error('Excalidraw rendering error', error);
                        showDiagramError(element, 'Excalidraw', error.message, source);
                    }
                });
            }

            function renderAllDiagrams() {
                renderMermaidDiagrams();
                renderVegaVisualizations();
                renderExcalidrawDiagrams();
            }

            function setStatus(message) {
                statusMessage.textContent = message || '';
            }

            function setConnectionStatus(connected) {
                offlineOverlay.classList.toggle('visible', !connected);
            }

            function updateHeader() {
                fileName.textContent = currentFile || 'No file selected';
                sidebarPath.textContent = resolvedRootPath || originalPathArgument || 'Unknown';
                const hasFile = Boolean(currentFile);
                downloadButton.disabled = !hasFile;
                deleteButton.disabled = !hasFile;
                editButton.disabled = !hasFile && !isEditing;
                previewButton.disabled = !hasFile;
                saveButton.disabled = !hasFile;
                cancelButton.disabled = false;
                updateActionVisibility();
            }

            function updateActionVisibility() {
                const hasFile = Boolean(currentFile);
                editButton.classList.toggle('hidden', !hasFile || (isEditing && !isPreviewing));
                previewButton.classList.toggle('hidden', !isEditing || isPreviewing);
                saveButton.classList.toggle('hidden', !isEditing);
                cancelButton.classList.toggle('hidden', !isEditing);
                downloadButton.classList.toggle('hidden', isEditing);
                deleteButton.classList.toggle('hidden', isEditing);
            }

            function buildQuery(params) {
                const query = new URLSearchParams();
                if (originalPathArgument) {
                    query.set('path', originalPathArgument);
                }
                Object.entries(params).forEach(([key, value]) => {
                    if (value !== undefined && value !== null && value !== '') {
                        query.set(key, value);
                    }
                });
                const queryString = query.toString();
                return queryString ? `?${queryString}` : '';
            }

            function updateLocation(file, { replace = false } = {}) {
                const newQuery = buildQuery({ file });
                const newUrl = `${window.location.pathname}${newQuery}`;
                const currentUrl = `${window.location.pathname}${window.location.search}`;
                const stateData = { file };

                if (replace || newUrl === currentUrl) {
                    window.history.replaceState(stateData, '', newUrl);
                } else {
                    window.history.pushState(stateData, '', newUrl);
                }
            }

            function fileFromSearch(search) {
                const params = new URLSearchParams(search || '');
                const value = params.get('file');
                if (typeof value !== 'string') {
                    return '';
                }
                const trimmed = value.trim();
                return trimmed === '' ? '' : trimmed;
            }

            function renderMarkdown(markdownText, options = {}) {
                cleanupExcalidrawRoots();
                configureMarked();
                updateRelativeLinkBase(currentFile);
                mermaidIdCounter = 0;
                vegaIdCounter = 0;
                excalidrawIdCounter = 0;

                // Reset slug counter for each document to ensure unique IDs
                documentSlugCounts = new Map();

                const sourceText = markdownText || '';
                const updateCurrent = Boolean(options.updateCurrent);

                if (typeof marked === 'undefined') {
                    activeHeadingCollection = null;
                    pendingMarkdown = sourceText;
                    content.textContent = sourceText;
                    updateTableOfContents([]);
                    waitForCoreLibraries().then(() => {
                        if (pendingMarkdown !== null) {
                            const textToRender = pendingMarkdown;
                            pendingMarkdown = null;
                            renderMarkdown(textToRender, { updateCurrent });
                        }
                    });
                    if (updateCurrent) {
                        currentContent = sourceText;
                    }
                    return;
                }

                activeHeadingCollection = [];
                content.innerHTML = marked.parse(sourceText);
                const headings = Array.isArray(activeHeadingCollection) ? [...activeHeadingCollection] : [];
                activeHeadingCollection = null;
                pendingMarkdown = null;

                if (typeof hljs !== 'undefined') {
                    content.querySelectorAll('pre code').forEach((block) => {
                        if (block.closest('.mermaid, .vega-diagram, .excalidraw-diagram')) {
                            return;
                        }
                        try {
                            hljs.highlightElement(block);
                        } catch (err) {
                            console.warn('Highlight.js error', err);
                        }
                    });
                }

                updateTableOfContents(headings);
                renderAllDiagrams();
                if (updateCurrent) {
                    currentContent = sourceText;
                }
            }

            function updateTableOfContents(headings) {
                if (!tocList) {
                    return;
                }

                tocList.innerHTML = '';

                if (!Array.isArray(headings) || headings.length === 0) {
                    const emptyState = document.createElement('p');
                    emptyState.className = 'toc-empty-state';
                    emptyState.textContent = 'No headings found in this document yet.';
                    tocList.appendChild(emptyState);
                    return;
                }

                const minLevel = headings.reduce((accumulator, entry) => {
                    const level = typeof entry.level === 'number' ? entry.level : 1;
                    return Math.min(accumulator, Math.max(1, Math.min(6, level)));
                }, 6);

                const list = document.createElement('ol');
                list.setAttribute('role', 'list');

                headings.forEach((entry) => {
                    const level = Math.max(1, Math.min(6, entry.level || 1));
                    const item = document.createElement('li');
                    item.className = 'toc-entry';

                    const link = document.createElement('a');
                    link.className = 'toc-link';
                    link.href = `#${entry.slug}`;
                    link.textContent = entry.text || entry.slug || 'Untitled section';
                    link.setAttribute('aria-level', String(level));
                    link.dataset.level = String(level);
                    const indentLevel = Math.max(0, level - minLevel);
                    link.style.paddingLeft = `${10 + indentLevel * 16}px`;

                    item.appendChild(link);
                    list.appendChild(item);
                });

                tocList.appendChild(list);
            }

            function handleTocClick(event) {
                const link = event.target.closest('a.toc-link');
                if (!link) {
                    return;
                }

                const hash = link.getAttribute('href');
                if (typeof hash !== 'string' || !hash.startsWith('#')) {
                    return;
                }

                const targetId = hash.slice(1);
                if (!targetId) {
                    return;
                }

                const targetElement = document.getElementById(targetId);
                if (!targetElement) {
                    return;
                }

                event.preventDefault();

                try {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } catch (error) {
                    targetElement.scrollIntoView();
                }

                if (typeof history !== 'undefined' && typeof history.replaceState === 'function') {
                    const newUrl = `${window.location.pathname}${window.location.search}#${targetId}`;
                    history.replaceState(history.state, '', newUrl);
                }
            }

            if (tocList) {
                tocList.addEventListener('click', handleTocClick);
            }

            // ------------------------------------------------------------------
            // Markdown editing helpers
            // ------------------------------------------------------------------
            function ensureEditorInstance() {
                if (editorInstance) {
                    return editorInstance;
                }
                if (typeof window.CodeMirror === 'undefined') {
                    return null;
                }

                editorContainer.innerHTML = '';
                editorInstance = window.CodeMirror(editorContainer, {
                    value: draftContent,
                    mode: 'markdown',
                    theme: 'darcula',
                    lineNumbers: true,
                    lineWrapping: true,
                    autofocus: true,
                });
                editorInstance.setSize('100%', '100%');
                return editorInstance;
            }

            function enterEditMode() {
                if (!currentFile) {
                    return;
                }
                if (typeof window.CodeMirror === 'undefined') {
                    setStatus('Editor resources are still loading. Please try again in a moment.');
                    return;
                }

                isEditing = true;
                isPreviewing = false;
                draftContent = currentContent;
                const editor = ensureEditorInstance();
                if (!editor) {
                    isEditing = false;
                    setStatus('Editor resources are still loading. Please try again in a moment.');
                    updateActionVisibility();
                    return;
                }

                editor.setValue(draftContent);
                window.setTimeout(() => {
                    editor.refresh();
                    editor.focus();
                }, 0);

                content.classList.add('hidden');
                editorContainer.classList.add('visible');
                updateHeader();
                setStatus('Editing markdown…');
            }

            function enterPreviewMode() {
                if (!isEditing) {
                    return;
                }
                const editor = ensureEditorInstance();
                if (editor) {
                    draftContent = editor.getValue();
                }
                isPreviewing = true;
                renderMarkdown(draftContent, { updateCurrent: false });
                editorContainer.classList.remove('visible');
                content.classList.remove('hidden');
                updateHeader();
                setStatus('Previewing changes.');
            }

            function returnToCodeMode() {
                if (!isPreviewing) {
                    return;
                }
                isPreviewing = false;
                renderMarkdown(currentContent, { updateCurrent: true });
                content.classList.add('hidden');
                editorContainer.classList.add('visible');
                const editor = ensureEditorInstance();
                if (editor) {
                    window.setTimeout(() => {
                        editor.refresh();
                        editor.focus();
                    }, 0);
                }
                updateHeader();
                setStatus('Editing markdown…');
            }

            function exitEditMode(options = {}) {
                const { restoreContent = true } = options;
                if (!isEditing && !isPreviewing) {
                    updateHeader();
                    return;
                }
                isEditing = false;
                isPreviewing = false;
                draftContent = '';
                content.classList.remove('hidden');
                editorContainer.classList.remove('visible');
                if (restoreContent) {
                    renderMarkdown(currentContent, { updateCurrent: true });
                }
                updateHeader();
            }


            function resetViewToFallback(options = {}) {
                const { skipHistory = false } = options;
                exitEditMode({ restoreContent: false });
                currentFile = null;
                const fallback = fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path');
                renderMarkdown(fallback, { updateCurrent: true });
                updateActiveFileHighlight();
                updateHeader();
                if (!skipHistory) {
                    updateLocation('', { replace: true });
                }
            }
            function renderFileList() {
                fileList.innerHTML = '';

                const treeToRender = Array.isArray(fileTree) && fileTree.length
                    ? fileTree
                    : buildTreeFromFlatList(files);

                if (!treeToRender.length) {
                    const empty = document.createElement('li');
                    empty.className = 'empty-state';
                    empty.textContent = 'No markdown files yet';
                    fileList.appendChild(empty);
                    return;
                }

                ensureExpandedForCurrentFile(currentFile);

                const visited = new Set();
                const fragment = document.createDocumentFragment();
                treeToRender.forEach((node) => {
                    fragment.appendChild(renderTreeNode(node, 0, visited));
                });
                fileList.appendChild(fragment);

                const stale = [];
                expandedDirectories.forEach((value) => {
                    if (!visited.has(value)) {
                        stale.push(value);
                    }
                });
                stale.forEach((value) => expandedDirectories.delete(value));

                knownDirectories.clear();
                visited.forEach((value) => knownDirectories.add(value));

                updateActiveFileHighlight();
            }

            function renderTreeNode(node, depth, visited) {
                const item = document.createElement('li');
                item.className = `tree-node ${node.type === 'directory' ? 'directory-node' : 'file-node'}`;

                if (node.type === 'directory') {
                    const pathKey = typeof node.relativePath === 'string' ? node.relativePath : '';
                    visited.add(pathKey);

                    if (!knownDirectories.has(pathKey) && !expandedDirectories.has(pathKey)) {
                        expandedDirectories.add(pathKey);
                    }

                    const row = document.createElement('div');
                    row.className = 'tree-row directory-row';
                    row.style.paddingLeft = `${depth * 16}px`;

                    const isExpanded = expandedDirectories.has(pathKey);
                    const toggle = document.createElement('button');
                    toggle.type = 'button';
                    toggle.className = 'tree-toggle';
                    toggle.setAttribute('aria-expanded', String(isExpanded));
                    toggle.setAttribute('aria-label', `${isExpanded ? 'Collapse' : 'Expand'} ${node.name}`);
                    toggle.textContent = isExpanded ? '▾' : '▸';
                    toggle.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        toggleDirectory(pathKey);
                    });

                    const label = document.createElement('button');
                    label.type = 'button';
                    label.className = 'tree-label directory-label';

                    // Create folder icon element
                    const folderIcon = document.createElement('i');
                    folderIcon.className = isExpanded ? 'directory-icon fas fa-folder-open' : 'directory-icon fas fa-folder';

                    // Create text element
                    const labelText = document.createElement('span');
                    labelText.textContent = node.name;

                    // Append icon and text to label
                    label.appendChild(folderIcon);
                    label.appendChild(labelText);

                    label.addEventListener('click', (event) => {
                        event.preventDefault();
                        toggleDirectory(pathKey);
                    });

                    row.appendChild(toggle);
                    row.appendChild(label);
                    item.appendChild(row);

                    const childrenList = document.createElement('ul');
                    childrenList.className = 'tree-children';
                    if (!isExpanded) {
                        childrenList.classList.add('collapsed');
                    }
                    const children = Array.isArray(node.children) ? node.children : [];
                    children.forEach((child) => {
                        childrenList.appendChild(renderTreeNode(child, depth + 1, visited));
                    });
                    item.appendChild(childrenList);
                    return item;
                }

                const button = document.createElement('button');
                button.className = 'file-button';
                button.type = 'button';

                // Create icon element
                const icon = document.createElement('i');
                icon.className = 'file-icon fab fa-markdown'; // Font Awesome markdown icon

                // Create text element
                const text = document.createElement('span');
                text.textContent = node.name;

                // Append icon and text to button
                button.appendChild(icon);
                button.appendChild(text);

                button.dataset.file = node.relativePath;
                button.style.paddingLeft = `${depth * 16 + 24}px`;
                button.addEventListener('click', () => {
                    if (node.relativePath !== currentFile) {
                        selectFile(node.relativePath);
                    }
                });
                item.appendChild(button);
                return item;
            }

            function ensureExpandedForCurrentFile(filePath) {
                if (typeof filePath !== 'string' || !filePath.includes('/')) {
                    return;
                }
                const parts = filePath.split('/');
                parts.pop();
                let prefix = '';
                parts.forEach((segment) => {
                    if (!segment) {
                        return;
                    }
                    prefix = prefix ? `${prefix}/${segment}` : segment;
                    expandedDirectories.add(prefix);
                });
            }

            function toggleDirectory(pathKey) {
                if (!pathKey && pathKey !== '') {
                    return;
                }
                if (expandedDirectories.has(pathKey)) {
                    expandedDirectories.delete(pathKey);
                } else {
                    expandedDirectories.add(pathKey);
                }
                renderFileList();
            }

            function updateActiveFileHighlight() {
                fileList.querySelectorAll('.file-button').forEach((button) => {
                    button.classList.toggle('active', button.dataset.file === currentFile);
                });
            }

            async function fetchJson(url, options) {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `Request failed with status ${response.status}`);
                }
                return response.json();
            }

            async function refreshFiles() {
                const url = `/api/files${buildQuery({})}`;
                const data = await fetchJson(url);
                resolvedRootPath = data.rootPath || resolvedRootPath;
                const updatedIndex = normaliseFileIndex({ filesValue: data.files, treeValue: data.tree });
                files = updatedIndex.files;
                fileTree = updatedIndex.tree;
                renderFileList();
                if (!files.find((entry) => entry.relativePath === currentFile)) {
                    currentFile = files.length ? files[0].relativePath : null;
                    if (currentFile) {
                        await loadFile(currentFile, { replaceHistory: true });
                    } else {
                        currentFile = null;
                        exitEditMode({ restoreContent: false });
                        renderMarkdown(
                            fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path'),
                            { updateCurrent: true }
                        );
                        updateLocation('', { replace: true });
                        updateHeader();
                    }
                } else {
                    updateActiveFileHighlight();
                    updateHeader();
                }
            }

            function fallbackMarkdownFor(path) {
                return `# No markdown files found\n\nThe directory \`${path}\` does not contain any markdown files yet.`;
            }

            async function loadFile(file, options = {}) {
                const { skipHistory = false, replaceHistory = false } = options;
                if (isEditing || isPreviewing) {
                    setStatus('Editing session closed because the file was reloaded.');
                    exitEditMode();
                } else {
                    setStatus('');
                }
                const url = `/api/file${buildQuery({ file })}`;
                try {
                    const data = await fetchJson(url);
                    resolvedRootPath = data.rootPath || resolvedRootPath;
                    currentFile = data.file || file;
                    renderMarkdown(data.content || '', { updateCurrent: true });
                    updateActiveFileHighlight();
                    updateHeader();
                    updateLocation(currentFile, { replace: replaceHistory || skipHistory });
                } catch (err) {
                    setStatus(err.message);
                    console.error('Failed to load file', err);
                }
            }

            async function selectFile(file) {
                if (isEditing || isPreviewing) {
                    const discard = window.confirm('Discard unsaved changes?');
                    if (!discard) {
                        return;
                    }
                    exitEditMode();
                }
                await loadFile(file);
            }

            function setupActions() {
                editButton.addEventListener('click', () => {
                    if (isEditing && isPreviewing) {
                        returnToCodeMode();
                        return;
                    }
                    if (!isEditing) {
                        enterEditMode();
                    }
                });

                previewButton.addEventListener('click', () => {
                    if (!currentFile) {
                        return;
                    }
                    enterPreviewMode();
                });

                cancelButton.addEventListener('click', () => {
                    if (!isEditing && !isPreviewing) {
                        return;
                    }
                    exitEditMode();
                    setStatus('Edits cancelled.');
                });

                saveButton.addEventListener('click', async () => {
                    if (!isEditing || !currentFile) {
                        return;
                    }
                    const editor = ensureEditorInstance();
                    if (editor && !isPreviewing) {
                        draftContent = editor.getValue();
                    }
                    const contentToSave = isPreviewing ? draftContent : draftContent || (editor ? editor.getValue() : '');

                    setStatus('Saving changes…');
                    try {
                        await fetchJson(`/api/file${buildQuery({ file: currentFile })}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content: contentToSave }),
                        });
                        currentContent = contentToSave;
                        exitEditMode();
                        setStatus('Changes saved.');
                        updateActiveFileHighlight();
                        updateHeader();
                    } catch (err) {
                        setStatus(err.message);
                        console.error('Save failed', err);
                    }
                });

                downloadButton.addEventListener('click', async () => {
                    if (!currentFile) {
                        return;
                    }
                    try {
                        const data = await fetchJson(`/api/file${buildQuery({ file: currentFile })}`);
                        const blob = new Blob([data.content || ''], { type: 'text/markdown' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = currentFile;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    } catch (err) {
                        setStatus(err.message);
                        console.error('Download failed', err);
                    }
                });

                deleteButton.addEventListener('click', async () => {
                    if (!currentFile) {
                        return;
                    }
                    const confirmed = window.confirm(`Delete ${currentFile}?`);
                    if (!confirmed) {
                        return;
                    }
                    try {
                        await fetchJson(`/api/file${buildQuery({ file: currentFile })}`, { method: 'DELETE' });
                        setStatus('File deleted.');
                        await refreshFiles();
                    } catch (err) {
                        setStatus(err.message);
                        console.error('Delete failed', err);
                    }
                });
            }

            function connectWebSocket() {
                if (websocket) {
                    websocket.close();
                }

                const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
                websocket = new WebSocket(`${protocol}://${window.location.host}/ws`);

                websocket.addEventListener('open', () => {
                    setConnectionStatus(true);
                    websocket.send(JSON.stringify({ type: 'subscribe', path: originalPathArgument }));
                });

                websocket.addEventListener('message', async (event) => {
                    try {
                        const payload = JSON.parse(event.data);
                        if (payload.type === 'directory_update') {
                            resolvedRootPath = payload.path || resolvedRootPath;
                            const updatedIndex = normaliseFileIndex({
                                filesValue: payload.files,
                                treeValue: payload.tree,
                            });
                            files = updatedIndex.files;
                            fileTree = updatedIndex.tree;
                            renderFileList();
                            if (!files.find((entry) => entry.relativePath === currentFile)) {
                                currentFile = files.length ? files[0].relativePath : null;
                                if (currentFile) {
                                    await loadFile(currentFile, { replaceHistory: true });
                                } else {
                                    currentFile = null;
                                    exitEditMode({ restoreContent: false });
                                    renderMarkdown(
                                        fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path'),
                                        { updateCurrent: true }
                                    );
                                    updateLocation('', { replace: true });
                                    updateHeader();
                                }
                            } else {
                                updateActiveFileHighlight();
                                updateHeader();
                            }
                        } else if (payload.type === 'file_changed') {
                            if (payload.file && payload.file === currentFile) {
                                await loadFile(currentFile, { replaceHistory: true });
                            }
                        }
                    } catch (err) {
                        console.error('Failed to process websocket event', err);
                    }
                });

                function scheduleReconnect() {
                    if (reconnectTimer) {
                        return;
                    }
                    reconnectTimer = window.setTimeout(() => {
                        reconnectTimer = null;
                        connectWebSocket();
                    }, 1500);
                }

                websocket.addEventListener('close', () => {
                    setConnectionStatus(false);
                    scheduleReconnect();
                });

                websocket.addEventListener('error', () => {
                    websocket.close();
                });
            }

            function scheduleTerminalLibraryRetry() {
                if (terminalLibraryRetryTimer) {
                    return;
                }
                terminalLibraryRetryTimer = window.setTimeout(() => {
                    terminalLibraryRetryTimer = null;
                    if (!terminalInstance) {
                        ensureTerminalInstance();
                    }
                    if (!terminalSocket) {
                        connectTerminal();
                    }
                }, 250);
            }

            function areTerminalLibrariesReady() {
                return (
                    typeof window !== 'undefined' &&
                    typeof window.Terminal === 'function' &&
                    window.FitAddon &&
                    typeof window.FitAddon.FitAddon === 'function'
                );
            }

            function ensureTerminalInstance() {
                if (terminalInstance || !terminalContainer) {
                    return terminalInstance;
                }

                if (!areTerminalLibrariesReady()) {
                    scheduleTerminalLibraryRetry();
                    return null;
                }

                try {
                    terminalInstance = new window.Terminal({
                        convertEol: true,
                        cursorBlink: true,
                        fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                        fontSize: 13,
                        theme: {
                            background: '#0d1117',
                            foreground: '#c9d1d9',
                            cursor: '#58a6ff',
                            black: '#010409',
                            brightBlack: '#30363d',
                        },
                    });
                } catch (error) {
                    console.warn('Failed to initialise terminal instance', error);
                    terminalInstance = null;
                    return null;
                }

                try {
                    terminalFitAddon = new window.FitAddon.FitAddon();
                    terminalInstance.loadAddon(terminalFitAddon);
                } catch (error) {
                    console.warn('Failed to load terminal fit addon', error);
                    terminalInstance.dispose();
                    terminalInstance = null;
                    return null;
                }

                terminalInstance.open(terminalContainer);
                terminalInstance.focus();

                terminalInstance.onData((data) => {
                    if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                        terminalSocket.send(JSON.stringify({ type: 'input', data }));
                    }
                });

                terminalInstance.onResize((size) => {
                    if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                        terminalSocket.send(
                            JSON.stringify({ type: 'resize', cols: size.cols, rows: size.rows })
                        );
                    }
                });

                scheduleTerminalFit();
                return terminalInstance;
            }

            function scheduleTerminalFit() {
                if (!terminalInstance || !terminalFitAddon || terminalCollapsed) {
                    return;
                }

                if (pendingTerminalFitFrame) {
                    window.cancelAnimationFrame(pendingTerminalFitFrame);
                }

                pendingTerminalFitFrame = window.requestAnimationFrame(() => {
                    pendingTerminalFitFrame = null;
                    fitTerminal();
                });
            }

            function fitTerminal() {
                if (!terminalInstance || !terminalFitAddon || terminalCollapsed) {
                    return;
                }

                try {
                    terminalFitAddon.fit();
                } catch (error) {
                    console.warn('Unable to fit terminal to container', error);
                    return;
                }

                sendTerminalResize();
            }

            function sendTerminalResize() {
                if (!terminalInstance || !terminalSocket || terminalSocket.readyState !== WebSocket.OPEN) {
                    return;
                }
                terminalSocket.send(
                    JSON.stringify({ type: 'resize', cols: terminalInstance.cols, rows: terminalInstance.rows })
                );
            }

            function updateTerminalStatus(message) {
                if (terminalStatusText) {
                    terminalStatusText.textContent = message || '';
                }
                terminalLastStatusMessage = message || '';
            }

            function scheduleTerminalReconnect(delay = 1500) {
                if (terminalReconnectTimer) {
                    return;
                }
                terminalReconnectTimer = window.setTimeout(() => {
                    terminalReconnectTimer = null;
                    connectTerminal();
                }, delay);
            }

            function connectTerminal() {
                if (!terminalContainer) {
                    return;
                }

                if (terminalSocket &&
                    (terminalSocket.readyState === WebSocket.OPEN || terminalSocket.readyState === WebSocket.CONNECTING)) {
                    return;
                }

                const terminal = ensureTerminalInstance();
                if (!terminal) {
                    scheduleTerminalLibraryRetry();
                    return;
                }

                const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
                const socket = new WebSocket(`${protocol}://${window.location.host}/ws/terminal`);
                socket.binaryType = 'arraybuffer';
                terminalSocket = socket;
                updateTerminalStatus('Connecting…');

                socket.addEventListener('open', () => {
                    if (terminalReconnectTimer) {
                        window.clearTimeout(terminalReconnectTimer);
                        terminalReconnectTimer = null;
                    }
                    updateTerminalStatus('Connected');
                    scheduleTerminalFit();
                });

                socket.addEventListener('message', (event) => {
                    if (!terminalInstance) {
                        return;
                    }

                    if (typeof event.data === 'string') {
                        try {
                            const payload = JSON.parse(event.data);
                            if (payload.type === 'state' && typeof payload.message === 'string') {
                                updateTerminalStatus(payload.message);
                                return;
                            }
                            if (payload.type === 'exit') {
                                if (typeof payload.code === 'number') {
                                    updateTerminalStatus(`Process exited (${payload.code})`);
                                } else {
                                    updateTerminalStatus('Process exited');
                                }
                                scheduleTerminalReconnect();
                                return;
                            }
                        } catch (error) {
                            // Treat as raw output when parsing fails.
                            terminalInstance.write(event.data);
                            return;
                        }

                        terminalInstance.write(event.data);
                        return;
                    }

                    const consumeBuffer = (buffer) => {
                        if (!buffer) {
                            return;
                        }
                        const text = terminalDecoder.decode(buffer);
                        if (text) {
                            terminalInstance.write(text);
                        }
                    };

                    if (event.data instanceof ArrayBuffer) {
                        consumeBuffer(new Uint8Array(event.data));
                        return;
                    }

                    if (event.data && typeof event.data.arrayBuffer === 'function') {
                        event.data
                            .arrayBuffer()
                            .then((buffer) => consumeBuffer(new Uint8Array(buffer)))
                            .catch((error) => console.warn('Failed to decode terminal payload', error));
                    }
                });

                socket.addEventListener('close', () => {
                    terminalSocket = null;
                    if (!terminalLastStatusMessage.startsWith('Process exited')) {
                        updateTerminalStatus('Disconnected – reconnecting…');
                    }
                    scheduleTerminalReconnect();
                });

                socket.addEventListener('error', () => {
                    updateTerminalStatus('Connection error');
                    socket.close();
                });
            }

            function setupTerminalPanel() {
                if (!terminalPanel) {
                    return;
                }

                const minHeight = 140;

                const clampHeight = (value) => {
                    const max = Math.max(minHeight, Math.round(window.innerHeight * 0.75));
                    if (Number.isFinite(value)) {
                        return Math.min(Math.max(value, minHeight), max);
                    }
                    return minHeight;
                };

                const persistHeight = () => {
                    if (typeof window.localStorage === 'undefined') {
                        return;
                    }
                    try {
                        window.localStorage.setItem(terminalStorageKey, String(terminalHeight));
                    } catch (error) {
                        // Ignore persistence errors (e.g. storage disabled).
                    }
                };

                const applyHeight = (value, { persist = false } = {}) => {
                    const clamped = clampHeight(value);
                    terminalHeight = clamped;
                    terminalPanel.style.height = `${clamped}px`;
                    if (persist) {
                        persistHeight();
                    }
                    scheduleTerminalFit();
                    return clamped;
                };

                const restoreHeightFromStorage = () => {
                    if (typeof window.localStorage === 'undefined') {
                        terminalHeight = clampHeight(terminalPanel.getBoundingClientRect().height || 260);
                        return;
                    }
                    let stored = null;
                    try {
                        stored = window.localStorage.getItem(terminalStorageKey);
                    } catch (error) {
                        stored = null;
                    }
                    const numeric = stored === null ? NaN : Number(stored);
                    if (Number.isFinite(numeric)) {
                        applyHeight(numeric);
                    } else {
                        terminalHeight = clampHeight(terminalPanel.getBoundingClientRect().height || 260);
                    }
                };

                const setCollapsed = (value) => {
                    const collapsed = Boolean(value);
                    if (terminalCollapsed === collapsed) {
                        return;
                    }
                    terminalCollapsed = collapsed;
                    terminalPanel.classList.toggle('is-collapsed', collapsed);
                    if (terminalToggleButton) {
                        terminalToggleButton.setAttribute('aria-expanded', String(!collapsed));
                        terminalToggleButton.textContent = collapsed ? 'Show terminal' : 'Hide terminal';
                    }

                    if (collapsed) {
                        terminalPanel.style.height = '';
                    } else {
                        applyHeight(terminalHeight || clampHeight(terminalPanel.getBoundingClientRect().height || 260));
                    }
                };

                restoreHeightFromStorage();

                if (terminalToggleButton) {
                    terminalToggleButton.addEventListener('click', () => {
                        if (terminalCollapsed) {
                            setCollapsed(false);
                            applyHeight(terminalHeight || clampHeight(terminalPanel.getBoundingClientRect().height || 260));
                        } else {
                            setCollapsed(true);
                        }
                    });
                }

                if (terminalResizeHandle) {
                    terminalResizeHandle.addEventListener('pointerdown', (event) => {
                        if (event.button !== 0) {
                            return;
                        }
                        if (terminalCollapsed) {
                            setCollapsed(false);
                        }
                        event.preventDefault();
                        const startY = event.clientY;
                        const startHeight = terminalPanel.getBoundingClientRect().height;

                        const handleMove = (moveEvent) => {
                            const delta = startY - moveEvent.clientY;
                            const next = clampHeight(startHeight + delta);
                            applyHeight(next);
                        };

                        const handleUp = () => {
                            document.removeEventListener('pointermove', handleMove);
                            document.removeEventListener('pointerup', handleUp);
                            persistHeight();
                            scheduleTerminalFit();
                        };

                        document.addEventListener('pointermove', handleMove);
                        document.addEventListener('pointerup', handleUp);
                    });

                    terminalResizeHandle.addEventListener('keydown', (event) => {
                        if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {
                            return;
                        }
                        event.preventDefault();
                        if (terminalCollapsed) {
                            setCollapsed(false);
                        }
                        const offset = event.key === 'ArrowUp' ? 32 : -32;
                        const next = clampHeight((terminalHeight || terminalPanel.getBoundingClientRect().height) + offset);
                        applyHeight(next, { persist: true });
                    });

                    terminalResizeHandle.addEventListener('dblclick', () => {
                        if (terminalCollapsed) {
                            setCollapsed(false);
                        }
                        applyHeight(clampHeight(260), { persist: true });
                    });
                }

                window.addEventListener('resize', () => {
                    if (terminalCollapsed) {
                        return;
                    }
                    const current = terminalHeight || terminalPanel.getBoundingClientRect().height;
                    const clamped = clampHeight(current);
                    if (clamped !== current) {
                        applyHeight(clamped, { persist: true });
                    } else {
                        scheduleTerminalFit();
                    }
                });

                setCollapsed(false);
                ensureTerminalInstance();
                connectTerminal();
            }

            window.addEventListener('beforeunload', () => {
                if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                    try {
                        terminalSocket.close();
                    } catch (error) {
                        // Swallow shutdown errors.
                    }
                }
            });

            function initialise() {
                const initialFallback = fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path');
                initialiseSidebars();
                renderMarkdown(state.content || initialFallback, { updateCurrent: true });
                renderFileList();
                updateHeader();
                if (state.error) {
                    setStatus(state.error);
                }
                setupActions();
                setupTerminalPanel();
                connectWebSocket();
                if (!currentFile && files.length) {
                    currentFile = files[0].relativePath;
                }

                if (!initialFileFromLocation && currentFile) {
                    loadFile(currentFile, { replaceHistory: true });
                }
            }

            window.addEventListener('popstate', () => {
                const targetFile = fileFromSearch(window.location.search);
                if (targetFile) {
                    if (targetFile !== currentFile) {
                        loadFile(targetFile, { skipHistory: true, replaceHistory: true });
                    }
                } else {
                    resetViewToFallback({ skipHistory: true });
                }
            });

            initialise();

            if (initialFileFromLocation) {
                loadFile(initialFileFromLocation, { replaceHistory: true });
            }
        })();
    </script>
</body>

</html>