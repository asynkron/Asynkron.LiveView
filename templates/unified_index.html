<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
        integrity="sha512-rO+olRTkcf304DQBxSWxln8JXCzTHlKnIdnMUwYvQa9/Jd4cQaNkItIUj6Z4nvW1dqK0SKXLbn9h4KwZTNtAyw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css"
        integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/one-dark.min.css"
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Vendored dockview assets to keep the layout available when public CDNs are down. -->
    <link rel="stylesheet" href="/static/dockview/dockview.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css"
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        :root {
            color-scheme: dark;
            --file-sidebar-width: 320px;
            --file-sidebar-min-width: 220px;
            --file-sidebar-max-width: 520px;
            --toc-sidebar-width: 260px;
            --toc-sidebar-min-width: 180px;
            --toc-sidebar-max-width: 420px;
            --sidebar-collapsed-width: 20px;
            --file-sidebar-current-width: var(--file-sidebar-width);
            --toc-sidebar-current-width: var(--toc-sidebar-width);
        }

        path {
            stroke: #c0c0c0;

        }

        .cluster rect {
            fill: #80808020 !important;
        }

        * {
            box-sizing: border-box;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .hidden {
            display: none !important;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: 100%;
            overflow: hidden;
        }

        #dockview-root {
            flex: 1 1 auto;
            min-height: 0;
            height: 100%;
        }

        #dockview-root.hidden {
            display: none;
        }

        .dockview-panel-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }

        .dockview-panel-container > * {
            flex: 1 1 auto;
            min-height: 0;
            min-width: 0;
        }

        .dockview-panel-terminal .terminal-panel {
            height: 100%;
            max-height: none;
            flex: 1 1 auto;
        }

        .dockview-panel-terminal .terminal-body {
            flex: 1 1 auto;
        }

        .dockview-panel-container .terminal-toolbar {
            flex: 0 0 auto;
        }

        .dv-groupview.dv-inactive-group > .dv-tabs-and-actions-container .dv-tabs-container > .dv-tab.dv-active-tab {
            background-color: #161b22 !important;
        }

        .dv-tabs-and-actions-container {
            background-color: #11151a !important;
        }

        .dv-tab .dv-default-tab .dv-default-tab-action,
        .dv-tabs-and-actions-container .dv-right-actions-container {
            display: none !important;
        }

        .dv-tab .dv-default-tab .dv-default-tab-content {
            margin-right: 0;
        }

        .panel-missing {
            padding: 16px;
            color: #ff7b72;
            font-size: 0.9rem;
        }

        a {
            color: #58a6ff;
        }

        .app-shell {
            display: grid;
            grid-template-columns: var(--toc-sidebar-current-width) 10px minmax(0, 1fr) 10px var(--file-sidebar-current-width);
            gap: 0;
            padding: 0;
            min-height: 0;
            height: 100%;
            overflow: hidden;
            flex: 1 1 auto;
        }

        @media (max-width: 980px) {
            .app-shell {
                grid-template-columns: 1fr;
                grid-auto-rows: auto;
            }

            .splitter {
                display: none;
            }

            .sidebar,
            .viewer {
                grid-column: 1 / -1;
            }

            .viewer {
                order: 0;
            }

            .sidebar {
                order: 1;
                height: auto;
                min-height: 0;
            }
        }

        .viewer {
            display: flex;
            flex-direction: column;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 0;
            min-height: 0;
            height: 100%;
            overflow: hidden;
        }

        .file-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
            padding: 16px;
            padding-left: 24px;
            border-bottom: 1px solid #30363d;
            background: #0d1117;
        }

        .file-header h1 {
            margin: 0;
            font-size: 1.6rem;
            color: #58a6ff;
        }

        .file-meta {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .file-meta small {
            color: #8b949e;
        }

        .file-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .layout-toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
            border-right: 1px solid #30363d;
            padding-right: 12px;
            margin-right: 12px;
        }

        .layout-toggle-group button {
            padding: 10px 12px;
        }

        .layout-toggle-group button[aria-pressed="false"] {
            background: transparent;
            color: #8b949e;
            border-color: #30363d;
        }

        .layout-toggle-group button[aria-pressed="false"] .file-button-icon {
            color: inherit;
        }

        @media (max-width: 720px) {
            .layout-toggle-group {
                width: 100%;
                justify-content: flex-end;
                border-right: none;
                border-bottom: 1px solid #30363d;
                padding-right: 0;
                padding-bottom: 8px;
                margin-right: 0;
                margin-bottom: 8px;
            }
        }

        .file-actions button {
            padding: 10px 14px;
            border-radius: 0;
            border: 1px solid transparent;
            background: #ffffff10;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s ease, background 0.2s ease;
        }

        .file-actions button.secondary {
            background: #30363d;
            color: #c9d1d9;
        }

        .file-actions button.danger {
            background: #da3633;
        }

        .file-actions button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .file-actions button:not(:disabled):hover {
            transform: translateY(-1px);
        }

        .file-button-icon {
            color: #58a6ff;
            font-size: 0.9rem;
            min-width: 16px;
            display: inline-block;
        }

        .status-message {
            color: #ffa657;
            font-size: 0.9rem;
        }

        .content-area {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .content-area.hidden {
            display: none;
        }

        .content-area h1,
        .content-area h2,
        .content-area h3,
        .content-area h4,
        .content-area h5,
        .content-area h6 {
            color: #f0f6fc;
            position: relative;
        }

        .heading-anchor {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: auto;
            height: auto;
            margin-left: 8px;
            color: #8b949e;
            text-decoration: none;
            opacity: 0;
            transition: opacity 0.2s ease, color 0.2s ease;
            font-size: 0.8em;
            font-weight: normal;
        }

        .heading-anchor::before {
            content: "#";
            font-family: inherit;
        }

        .heading-anchor:hover,
        .heading-anchor:focus-visible {
            color: #58a6ff;
            outline: none;
        }

        .heading-actions {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .heading-action-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid transparent;
            background: transparent;
            color: #8b949e;
            font-size: 0.7em;
            line-height: 1;
            cursor: pointer;
            transition: color 0.2s ease, background 0.2s ease, border-color 0.2s ease;
        }

        .heading-action-button i {
            pointer-events: none;
        }

        .heading-action-button:hover,
        .heading-action-button:focus-visible {
            color: #58a6ff;
            background: #ffffff10;
            border-color: #30363d;
            outline: none;
        }

        .content-area h1:hover .heading-anchor,
        .content-area h1:focus-within .heading-anchor,
        .content-area h2:hover .heading-anchor,
        .content-area h2:focus-within .heading-anchor,
        .content-area h3:hover .heading-anchor,
        .content-area h3:focus-within .heading-anchor,
        .content-area h4:hover .heading-anchor,
        .content-area h4:focus-within .heading-anchor,
        .content-area h5:hover .heading-anchor,
        .content-area h5:focus-within .heading-anchor,
        .content-area h6:hover .heading-anchor,
        .content-area h6:focus-within .heading-anchor,
        .content-area h1:hover .heading-actions,
        .content-area h1:focus-within .heading-actions,
        .content-area h2:hover .heading-actions,
        .content-area h2:focus-within .heading-actions,
        .content-area h3:hover .heading-actions,
        .content-area h3:focus-within .heading-actions,
        .content-area h4:hover .heading-actions,
        .content-area h4:focus-within .heading-actions,
        .content-area h5:hover .heading-actions,
        .content-area h5:focus-within .heading-actions,
        .content-area h6:hover .heading-actions,
        .content-area h6:focus-within .heading-actions {
            opacity: 1;
        }

        .CodeMirror .heading-target-line {
            background: rgba(88, 166, 255, 0.25);
        }

        .content-area code {
            background: #0d1117;
            border-radius: 6px;
            padding: 2px 5px;
        }

        .content-area pre {
            background: #0d1117;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
        }

        .diagram-loading {
            background: #1f242e;
            border: 1px dashed #30363d;
            border-radius: 8px;
            padding: 16px;
            margin: 24px 0;
            color: #8b949e;
            font-size: 0.95rem;
            line-height: 1.5;
            word-break: break-word;
        }

        .diagram-loading pre {
            margin-top: 12px;
            max-height: 320px;
            overflow: auto;
            background: rgba(13, 17, 23, 0.6);
            border-radius: 6px;
            padding: 12px;
        }

        .content-area .mermaid {
            display: block;
            margin: 24px 0;
        }

        .content-area .vega-diagram,
        .content-area .excalidraw-diagram {
            margin: 24px 0;
            position: relative;
            min-height: 120px;
            overflow: hidden;
        }

        .content-area .excalidraw-wrapper {
            width: 100%;
            min-height: 320px;
            height: clamp(320px, 65vh, 640px);
            pointer-events: none;
        }

        .content-area .excalidraw-wrapper canvas {
            pointer-events: none !important;
        }

        .content-area .excalidraw-wrapper .layer-ui__wrapper {
            display: none !important;
        }

        .editor-container {
            display: none;
            flex: 1;
            padding: 0;
            overflow: hidden;
            min-height: 320px;
            height: 100%;
            background: #161b22;
        }

        .editor-container.visible {
            display: block;
        }

        .editor-container .cm-s-one-dark.CodeMirror {
            height: 100%;
            font-size: 0.95rem;
            background: #161b22;
            color: #c9d1d9;
        }

        .editor-container .CodeMirror {
            height: 100%;
        }

        .editor-container .CodeMirror-scroll {
            max-height: 100%;
        }

        .editor-container .cm-s-one-dark .CodeMirror-scrollbar-filler,
        .editor-container .cm-s-one-dark .CodeMirror-scroll {
            background: #161b22;
        }

        .editor-container .cm-s-one-dark .CodeMirror-gutters {
            background: #161b22;
            border-right: 1px solid #30363d;
            color: #6e7681;
        }

        .editor-container .cm-s-one-dark .CodeMirror-linenumber {
            color: #6e7681;
        }

        .editor-container .cm-s-one-dark .CodeMirror-cursor {
            border-left: 1px solid #58a6ff;
        }

        .editor-container .cm-s-one-dark .CodeMirror-selected {
            background: rgba(88, 166, 255, 0.2);
        }

        .editor-container .cm-s-one-dark .CodeMirror-activeline-background {
            background: rgba(88, 166, 255, 0.08);
        }

        .editor-container .cm-s-one-dark .CodeMirror-activeline-gutter {
            background: rgba(88, 166, 255, 0.08);
            color: #c9d1d9;
        }

        .editor-container .cm-s-one-dark .CodeMirror-matchingbracket {
            color: #f0f6fc;
            border-bottom: 1px solid #58a6ff;
        }

        .editor-container .cm-s-one-dark span.cm-comment,
        .editor-container .cm-s-one-dark span.cm-quote {
            color: #5c6370;
            font-style: italic;
        }

        .editor-container .cm-s-one-dark span.cm-keyword,
        .editor-container .cm-s-one-dark span.cm-def,
        .editor-container .cm-s-one-dark span.cm-property {
            color: #c678dd;
        }

        .editor-container .cm-s-one-dark span.cm-operator {
            color: #56b6c2;
        }

        .editor-container .cm-s-one-dark span.cm-variable {
            color: #e06c75;
        }

        .editor-container .cm-s-one-dark span.cm-variable-2,
        .editor-container .cm-s-one-dark span.cm-variable-3,
        .editor-container .cm-s-one-dark span.cm-type,
        .editor-container .cm-s-one-dark span.cm-attribute {
            color: #e5c07b;
        }

        .editor-container .cm-s-one-dark span.cm-number,
        .editor-container .cm-s-one-dark span.cm-builtin
        {
            color: #d19a66;
        }

        .editor-container .cm-s-one-dark span.cm-string,
        .editor-container .cm-s-one-dark span.cm-string-2,
        .editor-container .cm-s-one-dark span.cm-hr {
            color: #98c379;
        }

        .editor-container .cm-s-one-dark span.cm-tag,
        .editor-container .cm-s-one-dark span.cm-header {
            color: #e06c75;
        }

        .editor-container .cm-s-one-dark span.cm-link,
        .editor-container .cm-s-one-dark span.cm-url,
        .editor-container .cm-s-one-dark span.cm-formatting-link,
        .editor-container .cm-s-one-dark span.cm-formatting-url {
            color: #61afef;
            text-decoration: underline;
        }

        .editor-container .cm-s-one-dark span.cm-atom {
            color: #56b6c2;
        }

        .editor-container .cm-s-one-dark span.cm-positive {
            color: #98c379;
        }

        .editor-container .cm-s-one-dark span.cm-negative {
            color: #e06c75;
        }

        .editor-container .cm-s-one-dark span.cm-error {
            color: #f85149;
            text-decoration: underline;
        }

        .sidebar {
            position: relative;
            display: flex;
            flex-direction: column;
            background: #161b22;

            border-radius: 0;
            padding: 0;
            gap: 0;
            height: 100%;
            min-height: 0;
            overflow: hidden;
            transition: box-shadow 0.2s ease;
        }

        .sidebar.is-expanded {

        }

        .sidebar-content {
            display: flex;
            flex-direction: column;
            gap: 0;
            height: 100%;
            min-height: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .sidebar.is-expanded .sidebar-content {
            opacity: 1;
            pointer-events: auto;
        }

        .sidebar-collapsed-label {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            font-size: 0.7rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: #8b949e;
            pointer-events: none;
            opacity: 0.65;
            transition: opacity 0.2s ease;
        }

        .sidebar.is-expanded .sidebar-collapsed-label {
            opacity: 0;
        }

        .sidebar.is-expanded .sidebar-collapsed-label::after {
            content: '';
        }

        .sidebar--toc .sidebar-collapsed-label {
            letter-spacing: 0.2em;
        }

        .sidebar--files .sidebar-collapsed-label {
            letter-spacing: 0.16em;
        }

        .sidebar-path {
            font-size: 0.8rem;
            color: #8b949e;
            word-break: break-all;
            line-height: 1.3;
            padding: 16px 20px 0;
        }

        .toc-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .toc-list ol {
            list-style: none;
            margin: 0;
            padding-left: 0;
        }

        .toc-entry {
            margin: 2px 0;
        }

        .toc-link {
            display: block;
            padding: 6px 10px;
            border-radius: 6px;
            color: #c9d1d9;
            text-decoration: none;
            font-size: 0.85rem;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .toc-link:hover,
        .toc-link:focus-visible {
            background: #1f242e;
            color: #58a6ff;
            outline: none;
        }

        .toc-empty-state {
            color: #8b949e;
            font-size: 0.85rem;
            padding: 8px 4px;
        }

        .file-list {
            list-style: none;
            margin: 0;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .file-list ul {
            list-style: none;
            margin: 4px 0 0;
            padding-left: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .tree-node {
            margin: 0;
        }

        .tree-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 2px 4px;
            background: transparent;
            transition: background 0.2s ease;
        }

        .tree-row:hover {
            background: #1f242e;
        }

        .tree-toggle {
            width: 18px;
            height: 18px;
            border: none;
            background: none;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
        }

        .tree-toggle:focus-visible,
        .tree-label:focus-visible,
        .file-button:focus-visible {
            outline: 2px solid #58a6ff;
            outline-offset: 1px;
        }

        .tree-label {
            flex: 1;
            background: none;
            border: none;
            color: inherit;
            text-align: left;
            cursor: pointer;
            padding: 4px 6px;
            font: inherit;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .directory-icon {
            font-size: 0.9rem;
            color: #58a6ff;
            flex-shrink: 0;
            min-width: 20px;
            text-align: center;
        }

        .directory-label {
            font-weight: normal;
        }

        .tree-children.collapsed {
            display: none;
        }

        .file-button {
            width: 100%;
            background: transparent;
            border: 1px solid transparent;
            color: inherit;
            padding: 6px 10px;
            text-align: left;
            cursor: pointer;
            transition: border 0.2s ease, background 0.2s ease;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-icon {
            font-size: 0.9rem;
            color: #58a6ff;
            flex-shrink: 0;
            min-width: 20px;
            text-align: center;
            margin-left: 8px;
        }

        .file-button:hover {
            background: #1f242e;
        }

        .file-button.active {
            background: #1f242e;
            border-color: #30363d;
            color: #c9d1d9;
        }

        .empty-state {
            color: #8b949e;
            font-size: 0.95rem;
            text-align: center;
            padding: 24px 12px;
        }

        .directory-path {
            font-size: 0.85rem;
            color: #8b949e;
            word-break: break-all;
        }

        .offline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(13, 17, 23, 0.9);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
        }

        .offline-overlay.visible {
            display: flex;
        }

        .offline-message {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            color: #c9d1d9;
            max-width: 400px;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.4);
        }

        .offline-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #30363d;
            border-top: 3px solid #58a6ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        body.modal-open {
            overflow: hidden;
        }

        .dialog-overlay {
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.85);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
        }

        .dialog-overlay.visible {
            display: flex;
        }

        .dialog-window {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 28px;
            width: min(420px, 92vw);
            box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
            color: #c9d1d9;
        }

        .dialog-window h3 {
            margin: 0 0 12px;
            font-size: 1.25rem;
            color: #f0f6fc;
        }

        .dialog-window p {
            margin: 0 0 20px;
            color: #8b949e;
            line-height: 1.5;
        }

        .dialog-detail {
            margin-top: -8px;
            margin-bottom: 24px;
        }

        .dialog-filename {
            color: #f0f6fc;
            font-weight: 600;
        }

        .dialog-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .dialog-actions button {
            padding: 10px 18px;
            border-radius: 6px;
            border: 1px solid transparent;
            font-weight: 600;
            cursor: pointer;
            background: #21262d;
            color: #c9d1d9;
            transition: background 0.2s ease, transform 0.1s ease, border-color 0.2s ease;
        }

        .dialog-actions button:hover,
        .dialog-actions button:focus-visible {
            background: #2b3440;
            border-color: #30363d;
            transform: translateY(-1px);
            outline: none;
        }

        .dialog-actions .primary {
            background: #238636;
            color: #ffffff;
        }

        .dialog-actions .primary:hover,
        .dialog-actions .primary:focus-visible {
            background: #2ea043;
            border-color: #3fb950;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .offline-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0 0 8px;
            color: #ff7b72;
        }

        .offline-description {
            font-size: 0.9rem;
            color: #8b949e;
            margin: 0;
        }

        .terminal-panel {
            background: #0d1117;
            border-top: 1px solid #30363d;
            display: flex;
            flex-direction: column;
            height: 260px;
            min-height: 48px;
            max-height: 75vh;
            transition: height 0.15s ease;
            flex: 0 0 auto;
        }

        .terminal-panel.is-collapsed {
            display: none;
        }

        .terminal-resize-handle {
            height: 6px;
            cursor: row-resize;
            background: linear-gradient(180deg, #30363d 0%, #21262d 100%);
            border-bottom: 1px solid #30363d;
        }

        .terminal-body {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .terminal-status-badge {
            position: absolute;
            top: 12px;
            right: 12px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(22, 27, 34, 0.85);
            border: 1px solid #30363d;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #8b949e;
            pointer-events: none;
        }

        #terminal-container {
            position: absolute;
            inset: 0;
        }

        .file-title {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 500;
            color: #c9d1d9;
        }

        body.dockview-active .file-title {
            display: none;
        }
    </style>
</head>

<body>
    <div id="dockview-root" class="dockview-theme-abyss hidden"></div>
    <div class="app-shell">
        <aside class="sidebar sidebar--toc is-expanded" data-sidebar="toc">
            <div class="sidebar-collapsed-label" aria-hidden="true">ToC</div>
            <div class="sidebar-content">
                <nav id="toc-list" class="toc-list" aria-label="Table of contents"></nav>
            </div>
        </aside>

        <section class="viewer">
            <header class="file-header">
                <div class="file-meta">
                    <h1 id="file-name">Markdown Viewer</h1>
                    <span id="status-message" class="status-message"></span>
                </div>
                <div class="file-actions">
                    <div class="layout-toggle-group" role="group" aria-label="Toggle panels">
                        <button id="toggle-toc-panel" type="button" data-panel-toggle="toc" aria-pressed="true"
                            class="secondary" aria-label="Toggle table of contents panel" title="Toggle table of contents panel">
                            <i class="fas fa-list file-button-icon" aria-hidden="true"></i>
                        </button>
                        <button id="toggle-files-panel" type="button" data-panel-toggle="files" aria-pressed="true"
                            class="secondary" aria-label="Toggle files panel" title="Toggle files panel">
                            <i class="fas fa-folder-tree file-button-icon" aria-hidden="true"></i>
                        </button>
                    </div>
                    <button id="edit-button" class="" title="Edit the current file"><i
                            class="fas fa-edit file-button-icon"></i></button>
                    <button id="preview-button" class=" hidden" title="Preview the pending changes"><i
                            class="fas fa-eye file-button-icon"></i></button>
                    <button id="save-button" class="hidden" title="Save your changes"><i
                            class="fas fa-save file-button-icon"></i></button>
                    <button id="cancel-button" class=" hidden" title="Cancel editing"><i
                            class="fas fa-times file-button-icon"></i></button>
                    <button id="download-button" title="Download the current file"><i
                            class="fas fa-download file-button-icon"></i></button>
                    <button id="delete-button" class="" title="Delete the current file"><i
                            class="fas fa-trash file-button-icon"></i></button>
                </div>
            </header>
            <div id="content" class="content-area"></div>
            <div id="editor-container" class="editor-container"></div>
        </section>

        <aside class="sidebar sidebar--files is-expanded" data-sidebar="files">
            <div class="sidebar-collapsed-label" aria-hidden="true">Files</div>
            <div class="sidebar-content">
                <div class="sidebar-header">
                    <div class="sidebar-path" id="sidebar-path"></div>
                </div>
                <ul id="file-list" class="file-list" role="tree"></ul>
            </div>
        </aside>
    </div>

    <div id="offline-overlay" class="offline-overlay">
        <div class="offline-message">
            <div class="offline-spinner"></div>
            <h3 class="offline-title">Connection Lost</h3>
            <p class="offline-description">Reconnecting to the live view server...</p>
        </div>
    </div>

    <div id="unsaved-changes-modal" class="dialog-overlay" role="dialog" aria-modal="true"
        aria-labelledby="unsaved-changes-title" aria-describedby="unsaved-changes-message" tabindex="-1">
        <div class="dialog-window">
            <h3 id="unsaved-changes-title">Unsaved changes</h3>
            <p id="unsaved-changes-message">You have unsaved changes in
                <span id="unsaved-changes-filename" class="dialog-filename"></span>.
            </p>
            <p id="unsaved-changes-detail" class="dialog-detail">What would you like to do?</p>
            <div class="dialog-actions">
                <button type="button" id="unsaved-changes-save" class="primary">Save changes</button>
                <button type="button" id="unsaved-changes-discard" class="secondary">Discard</button>
                <button type="button" id="unsaved-changes-cancel" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="terminal-panel" class="terminal-panel">

        <div class="terminal-body">
            <div id="terminal-container"></div>
        </div>
    </div>

    <script>
        window.__INITIAL_STATE__ = __INITIAL_STATE_JSON__;
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/14.1.2/marked.min.js"
        integrity="sha512-bXyBT2/sYjZg1D7ykDS6eJSE4DFDVPJHvbRAfdfYKr6IusrCz7wAmSm36vz9G8zMob25Rvqu90vft3JI71ygcQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/marked-base-url@1.1.7/lib/index.umd.js"
        integrity="sha512-vBt/Loem3LzFY7GzyW5LjD/RsH3CGU4ORjvDOiqEJDzPWCsCL6yKzCKid0oYSKyPAvH5j9RiwLs1L7QjKbgxEw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"
        integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js"
        integrity="sha512-gx05X612uoaolzJ5Ee/786b3th+qzAm90TOvRwZJwnE8yr0sHQG8eLxdR0/Hbqc2IFh2mWHzzXk79g3atNSwsQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"
        integrity="sha512-8Q6Y9XnTbOE+JNvjBQwJ2H8S+UV4uA6hiRykhdtIyDYZ2TprdNmWOUaKdGzOhyr4dCyk287OejbPvwl7lrfqrQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"
        integrity="sha512-MOCpqoRoisCTwJ8vQQiciZv0qcpROCidek3GTFS6KTk2+y7munJIlKCVkFCYY+p3ErYFXCjmFjnfTTRSC1OHWQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@excalidraw/excalidraw@0.17.4/dist/excalidraw.production.min.js"
        integrity="sha512-E2QYnMiPwJ0lKE9t8V7Ef/KcFgi/7LjV7LN9a9vavP2t1/mE9NfyANrt1imXfutaCK4jQo2ZhBPZbVCCqnvyYw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/vega@5.25.0/build/vega.min.js" crossorigin="anonymous"
        integrity="sha512-XX9YBZNtGu/Bz3d3zstE6vcEf4coHTGyxTwzU+0DNR7kHoD37krFcyWnqKTdzV6yWS9a5g3H3a71bM4ctzE1kA=="
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.15.0/build/vega-lite.min.js" crossorigin="anonymous"
        integrity="sha512-DFhjyQTRTao5MOf11Mxt3sft6Iamu6u7FlaarEW6VhIsN2flUUk30OZ5byOrxV3HCawL+YLalR2ZhKf2kBiLDw=="
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.22.2/build/vega-embed.min.js" crossorigin="anonymous"
        integrity="sha512-XGkG4fTLMPA3Lp9FUGv7MFNvzpAzC/QgC//cOSxjfhmj8fZjF8iyqn9rgXjwHiY1xqWFzn+BnH8R0oGClEIPvw=="
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"
        integrity="sha512-OeZ4Yrb/W7d2W4rAMOO0HQ9Ro/aWLtpW9BUSR2UOWnSV2hprXLkkYnnCGc9NeLUxxE4ZG7zN16UuT1Elqq8Opg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"
        integrity="sha512-DmMao0nRIbyDjbaHc8fNd3kxGsZj9PCU6Iu/CeidLQT9Py8nYVA5n0PqXYmvqNdU+lCiTHOM/4E7bM/G8BttJg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js" crossorigin="anonymous"
        referrerpolicy="no-referrer" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js" crossorigin="anonymous"
        referrerpolicy="no-referrer" defer></script>
    <script src="/static/dockview/dockview.min.js" defer></script>
    <script defer>
        function bootstrap() {
            const state = window.__INITIAL_STATE__ || {};
            const content = document.getElementById('content');
            const fileName = document.getElementById('file-name');
            const sidebarPath = document.getElementById('sidebar-path');
            const statusMessage = document.getElementById('status-message');
            const fileList = document.getElementById('file-list');
            const downloadButton = document.getElementById('download-button');
            const deleteButton = document.getElementById('delete-button');
            const editButton = document.getElementById('edit-button');
            const previewButton = document.getElementById('preview-button');
            const saveButton = document.getElementById('save-button');
            const cancelButton = document.getElementById('cancel-button');
            const editorContainer = document.getElementById('editor-container');
            const offlineOverlay = document.getElementById('offline-overlay');
            const unsavedChangesModal = document.getElementById('unsaved-changes-modal');
            const unsavedChangesFilename = document.getElementById('unsaved-changes-filename');
            const unsavedChangesMessage = document.getElementById('unsaved-changes-message');
            const unsavedChangesDetail = document.getElementById('unsaved-changes-detail');
            const unsavedChangesSaveButton = document.getElementById('unsaved-changes-save');
            const unsavedChangesDiscardButton = document.getElementById('unsaved-changes-discard');
            const unsavedChangesCancelButton = document.getElementById('unsaved-changes-cancel');
            const tocList = document.getElementById('toc-list');
            const tocSidebar = document.querySelector('.sidebar--toc');
            const fileSidebar = document.querySelector('.sidebar--files');
            const tocSplitter = document.getElementById('toc-splitter');
            const fileSplitter = document.getElementById('file-splitter');
            const dockviewRoot = document.getElementById('dockview-root');
            const appShell = document.querySelector('.app-shell');
            const rootElement = document.documentElement;
            const viewerSection = document.querySelector('.viewer');
            const terminalPanel = document.getElementById('terminal-panel');
            const terminalContainer = document.getElementById('terminal-container');
            const terminalToggleButton = document.getElementById('terminal-toggle');
            const terminalStatusText = document.getElementById('terminal-status');
            const terminalResizeHandle = document.getElementById('terminal-resize-handle');
            const terminalStorageKey = 'terminalPanelHeight';
            const panelToggleButtons = Array.from(document.querySelectorAll('[data-panel-toggle]'));
            const panelToggleButtonMap = new Map();

            panelToggleButtons.forEach((button) => {
                const panelName = button.dataset.panelToggle;
                if (!panelName) {
                    return;
                }

                panelToggleButtonMap.set(panelName, button);
                button.addEventListener('click', (event) => {
                    event.preventDefault();
                    const currentlyVisible = getPanelVisibility(panelName);
                    const nextVisible = !currentlyVisible;
                    setPanelVisibility(panelName, nextVisible);
                });
            });

            if (content) {
                content.addEventListener('click', handleHeadingActionClick);
            }

            const initialIndex = normaliseFileIndex({
                filesValue: state.files,
                treeValue: state.fileTree,
            });
            let currentFile = state.selectedFile || null;
            let files = initialIndex.files;
            let fileTree = initialIndex.tree;
            let websocket = null;
            let reconnectTimer = null;
            let isEditing = false;
            let isPreviewing = false;
            let editorInstance = null;
            let draftContent = '';
            let currentContent = typeof state.content === 'string' ? state.content : '';
            let hasPendingChanges = false;
            let suppressEditorChangeEvents = false;
            let activeUnsavedPrompt = null;

            const originalPathArgument = state.pathArgument || '';
            let resolvedRootPath = state.rootPath || '';
            const initialFileFromLocation = fileFromSearch(window.location.search);
            const textEncoder = new TextEncoder();
            const textDecoder = new TextDecoder();
            let markedConfigured = false;
            let mermaidInitAttempted = false;
            let mermaidRetryTimer = null;
            let vegaRetryTimer = null;
            let excalidrawRetryTimer = null;
            let mermaidIdCounter = 0;
            let vegaIdCounter = 0;
            let excalidrawIdCounter = 0;
            const excalidrawRoots = new Map();
            let excalidrawResizeHandlerAttached = false;
            let excalidrawFitFailureLogged = false;
            let librariesReadyPromise = null;
            let pendingMarkdown = null;
            let relativeLinksEnabled = false;
            let relativeLinkBasePath = '';
            let relativeLinkBaseWalker = null;
            let relativeLinkExtensionRegistered = false;
            let headingLocationMap = new Map();
            let headingHighlightLine = null;
            let headingHighlightTimeout = null;
            const relativeLinkDummyOrigin = 'http://__dummy__/';
            const relativeLinkSchemePattern = /^[a-zA-Z][\w+.-]*:/;
            const relativeLinkProtocolRelativePattern = /^\/\//;
            const expandedDirectories = new Set();
            const knownDirectories = new Set();
            const dockviewSetup = initialiseDockviewLayout();
            const dockviewIsActive = Boolean(dockviewSetup);
            document.body.classList.toggle('dockview-active', dockviewIsActive);
            refreshPanelToggleStates();
            let activeHeadingCollection = null;
            let documentSlugCounts = null;
            let terminalInstance = null;
            let terminalFitAddon = null;
            let terminalSocket = null;
            let terminalReconnectTimer = null;
            let terminalLibraryRetryTimer = null;
            let terminalCollapsed = false;
            let terminalHeight = null;
            let pendingTerminalFitFrame = null;
            let terminalResizeObserver = null;
            const terminalDecoder = new TextDecoder();
            let terminalLastStatusMessage = '';

            function updatePanelToggleButtonState(name, isVisible) {
                const button = panelToggleButtonMap.get(name);
                if (!button) {
                    return;
                }
                button.setAttribute('aria-pressed', String(Boolean(isVisible)));
            }

            function getPanelVisibility(name) {
                if (dockviewSetup && dockviewSetup.panels && dockviewSetup.panels[name]) {
                    const panel = dockviewSetup.panels[name];
                    const groupApi = panel?.group?.api;
                    if (groupApi && typeof groupApi.isVisible === 'boolean') {
                        return groupApi.isVisible;
                    }
                    return panel?.api?.isVisible ?? true;
                }

                if (name === 'toc' && tocSidebar) {
                    return !tocSidebar.classList.contains('hidden');
                }

                if (name === 'files' && fileSidebar) {
                    return !fileSidebar.classList.contains('hidden');
                }

                return true;
            }

            function toggleLegacySidebar(name, visible) {
                const targetSidebar = name === 'toc' ? tocSidebar : name === 'files' ? fileSidebar : null;
                if (!targetSidebar) {
                    return;
                }

                targetSidebar.classList.toggle('hidden', !visible);
                targetSidebar.classList.toggle('is-expanded', visible);

                const widthVar = name === 'toc' ? '--toc-sidebar-current-width' : '--file-sidebar-current-width';
                const defaultWidth = name === 'toc' ? 'var(--toc-sidebar-width)' : 'var(--file-sidebar-width)';

                rootElement.style.setProperty(
                    widthVar,
                    visible ? defaultWidth : 'var(--sidebar-collapsed-width)'
                );

                const splitter = name === 'toc' ? tocSplitter : fileSplitter;
                if (splitter) {
                    splitter.classList.toggle('hidden', !visible);
                }
            }

            function setPanelVisibility(name, visible) {
                if (dockviewSetup && dockviewSetup.panels && dockviewSetup.panels[name]) {
                    const panel = dockviewSetup.panels[name];
                    const groupApi = panel?.group?.api;

                    if (groupApi && typeof groupApi.setVisible === 'function') {
                        groupApi.setVisible(visible);
                    } else if (panel?.api && typeof panel.api.setVisible === 'function') {
                        panel.api.setVisible(visible);
                    }
                } else {
                    toggleLegacySidebar(name, visible);
                }

                if (name === 'toc' && tocSidebar) {
                    tocSidebar.classList.toggle('is-expanded', visible);
                } else if (name === 'files' && fileSidebar) {
                    fileSidebar.classList.toggle('is-expanded', visible);
                }

                updatePanelToggleButtonState(name, visible);
                window.requestAnimationFrame(() => {
                    updatePanelToggleButtonState(name, getPanelVisibility(name));
                });
            }

            function refreshPanelToggleStates() {
                panelToggleButtonMap.forEach((_button, name) => {
                    updatePanelToggleButtonState(name, getPanelVisibility(name));
                });
            }

            function initialiseDockviewLayout() {
                window.__dockviewSetup = null;

                if (!dockviewRoot) {
                    return null;
                }

                if (!window.dockview || !window.dockview.DockviewComponent) {
                    dockviewRoot.classList.add('hidden');
                    if (appShell) {
                        appShell.classList.remove('hidden');
                    }
                    window.__dockviewSetup = null;
                    return null;
                }

                if (!viewerSection || !tocSidebar || !fileSidebar || !terminalPanel) {
                    console.warn('Dockview initialisation skipped: missing panel sources.');
                    dockviewRoot.classList.add('hidden');
                    if (appShell) {
                        appShell.classList.remove('hidden');
                    }
                    window.__dockviewSetup = null;
                    return null;
                }

                if (tocSplitter && tocSplitter.parentElement) {
                    tocSplitter.parentElement.removeChild(tocSplitter);
                }
                if (fileSplitter && fileSplitter.parentElement) {
                    fileSplitter.parentElement.removeChild(fileSplitter);
                }

                const panelSources = {
                    viewer: viewerSection,
                    toc: tocSidebar,
                    files: fileSidebar,
                    terminal: terminalPanel,
                };

                if (tocSidebar) {
                    tocSidebar.classList.add('is-expanded');
                }

                if (fileSidebar) {
                    fileSidebar.classList.add('is-expanded');
                }

                const dockview = new window.dockview.DockviewComponent(dockviewRoot, {
                    hideBorders: true,
                    createComponent({ name }) {
                        const element = document.createElement('div');
                        element.classList.add('dockview-panel-container', `dockview-panel-${name}`);

                        const source = panelSources[name];
                        if (source) {
                            element.appendChild(source);
                        } else {
                            const placeholder = document.createElement('div');
                            placeholder.className = 'panel-missing';
                            placeholder.textContent = `Missing panel: ${name}`;
                            element.appendChild(placeholder);
                        }

                        return {
                            element,
                            init() { },
                            dispose() { },
                        };
                    },
                });

                const currentViewerTitle = (typeof currentFile === 'string' && currentFile.length)
                    ? currentFile
                    : 'Document';

                const viewerPanel = dockview.addPanel({
                    id: 'dockview-viewer',
                    component: 'viewer',
                    title: currentViewerTitle,
                });

                const tocPanel = dockview.addPanel({
                    id: 'dockview-toc',
                    component: 'toc',
                    title: 'Table of contents',
                    position: { referencePanel: viewerPanel, direction: 'left' },
                });

                const filesPanel = dockview.addPanel({
                    id: 'dockview-files',
                    component: 'files',
                    title: 'Files',
                    position: { referencePanel: viewerPanel, direction: 'right' },
                });

                const terminalDockviewPanel = dockview.addPanel({
                    id: 'dockview-terminal',
                    component: 'terminal',
                    title: 'Terminal',
                    position: { referencePanel: viewerPanel, direction: 'bottom' },
                });

                dockviewRoot.classList.remove('hidden');
                if (appShell) {
                    appShell.classList.add('hidden');
                }

                const setup = {
                    instance: dockview,
                    panels: {
                        viewer: viewerPanel,
                        toc: tocPanel,
                        files: filesPanel,
                        terminal: terminalDockviewPanel,
                    },
                };

                window.__dockviewSetup = setup;

                [
                    ['toc', tocPanel?.group?.api],
                    ['files', filesPanel?.group?.api],
                ].forEach(([name, api]) => {
                    if (api && typeof api.onDidVisibilityChange === 'function') {
                        api.onDidVisibilityChange(({ isVisible }) => {
                            updatePanelToggleButtonState(name, isVisible);
                        });
                    }
                });

                updatePanelToggleButtonState('toc', true);
                updatePanelToggleButtonState('files', true);

                return setup;
            }

            function normaliseFileIndex({ filesValue, treeValue }) {
                let flat = [];
                let tree = [];

                if (Array.isArray(filesValue)) {
                    flat = filesValue;
                } else if (filesValue && Array.isArray(filesValue.files)) {
                    flat = filesValue.files;
                    if (Array.isArray(filesValue.tree)) {
                        tree = filesValue.tree;
                    }
                }

                if (!tree.length && Array.isArray(treeValue)) {
                    tree = treeValue;
                }

                if (tree.length && !flat.length) {
                    flat = flattenTree(tree);
                }

                if (!tree.length && flat.length) {
                    tree = buildTreeFromFlatList(flat);
                }

                return { files: flat, tree };
            }

            function flattenTree(nodes) {
                const result = [];
                if (!Array.isArray(nodes)) {
                    return result;
                }

                const stack = [...nodes];
                while (stack.length) {
                    const node = stack.shift();
                    if (!node || typeof node !== 'object') {
                        continue;
                    }

                    if (node.type === 'file') {
                        result.push({
                            name: node.name,
                            relativePath: node.relativePath,
                            size: node.size,
                            updated: node.updated,
                        });
                        continue;
                    }

                    if (node.type === 'directory' && Array.isArray(node.children)) {
                        stack.unshift(...node.children);
                    }
                }

                return result;
            }

            function buildTreeFromFlatList(flatList) {
                if (!Array.isArray(flatList) || !flatList.length) {
                    return [];
                }

                const root = [];
                const directoryMap = new Map();
                directoryMap.set('', root);

                function ensureDirectory(path, name) {
                    if (directoryMap.has(path)) {
                        return directoryMap.get(path);
                    }

                    const parentPath = path.includes('/') ? path.slice(0, path.lastIndexOf('/')) : '';
                    const parentChildren = directoryMap.get(parentPath) || root;
                    const node = {
                        type: 'directory',
                        name,
                        relativePath: path,
                        children: [],
                    };
                    parentChildren.push(node);
                    directoryMap.set(path, node.children);
                    return node.children;
                }

                flatList.forEach((file) => {
                    if (!file || typeof file.relativePath !== 'string') {
                        return;
                    }

                    const segments = file.relativePath.split('/');
                    const fileName = segments.pop();
                    let currentPath = '';
                    segments.forEach((segment) => {
                        if (!segment) {
                            return;
                        }
                        currentPath = currentPath ? `${currentPath}/${segment}` : segment;
                        ensureDirectory(currentPath, segment);
                    });

                    const parentPath = segments.join('/');
                    const parentChildren = directoryMap.get(parentPath) || root;
                    parentChildren.push({
                        type: 'file',
                        name: fileName,
                        relativePath: file.relativePath,
                        size: file.size,
                        updated: file.updated,
                    });
                });

                sortTree(root);
                return root;
            }

            function sortTree(nodes) {
                if (!Array.isArray(nodes)) {
                    return;
                }
                nodes.sort((a, b) => {
                    if (a.type === b.type) {
                        return String(a.name || '').localeCompare(String(b.name || ''));
                    }
                    return a.type === 'directory' ? -1 : 1;
                });
                nodes.forEach((node) => {
                    if (node.type === 'directory') {
                        sortTree(node.children);
                    }
                });
            }

            function updateRelativeLinkBase(filePath) {
                if (typeof filePath !== 'string' || filePath.length === 0) {
                    relativeLinksEnabled = false;
                    relativeLinkBasePath = '';
                    relativeLinkBaseWalker = null;
                    return;
                }

                relativeLinksEnabled = true;
                const lastSlashIndex = filePath.lastIndexOf('/');
                relativeLinkBasePath = lastSlashIndex === -1 ? '' : filePath.slice(0, lastSlashIndex + 1);

                if (typeof markedBaseUrl !== 'undefined' && markedBaseUrl && typeof markedBaseUrl.baseUrl === 'function') {
                    const baseCandidate = relativeLinkBasePath || './';
                    try {
                        relativeLinkBaseWalker = markedBaseUrl.baseUrl(baseCandidate);
                    } catch (error) {
                        console.warn('Failed to initialise marked-base-url', error);
                        relativeLinkBaseWalker = null;
                    }
                } else {
                    relativeLinkBaseWalker = null;
                }
            }

            function decodePathSegments(path) {
                if (!path) {
                    return '';
                }
                return path
                    .split('/')
                    .map((segment) => {
                        try {
                            return decodeURIComponent(segment);
                        } catch {
                            return segment;
                        }
                    })
                    .join('/');
            }

            function encodePathSegments(path) {
                if (!path) {
                    return '';
                }
                return path
                    .split('/')
                    .map((segment) => encodeURIComponent(segment))
                    .join('/');
            }

            function fallbackResolveRelativeHref(href) {
                try {
                    const baseReference = relativeLinkBasePath ? relativeLinkBasePath : '.';
                    const baseUrl = new URL(baseReference, relativeLinkDummyOrigin);
                    const resolvedUrl = new URL(href, baseUrl);
                    const normalisedPath = resolvedUrl.pathname.replace(/^\/+/u, '');
                    const decodedPath = decodePathSegments(normalisedPath);
                    return `${decodedPath}${resolvedUrl.search}${resolvedUrl.hash}`;
                } catch (error) {
                    console.warn('Relative link fallback failed', error);
                    return href;
                }
            }

            function splitResolvedHref(resolvedHref) {
                if (typeof resolvedHref !== 'string' || resolvedHref.length === 0) {
                    return { filePath: '', search: '', hash: '' };
                }

                let working = resolvedHref;
                let hash = '';
                const hashIndex = working.indexOf('#');
                if (hashIndex !== -1) {
                    hash = working.slice(hashIndex);
                    working = working.slice(0, hashIndex);
                }

                let search = '';
                const searchIndex = working.indexOf('?');
                if (searchIndex !== -1) {
                    search = working.slice(searchIndex);
                    working = working.slice(0, searchIndex);
                }

                const cleaned = working.replace(/^\.\//, '').replace(/^\/+/u, '');
                const filePath = decodePathSegments(cleaned);
                return { filePath, search, hash };
            }

            function transformRelativeAsset(rawHref, tokenType) {
                if (!relativeLinksEnabled || typeof rawHref !== 'string') {
                    return null;
                }

                const trimmedHref = rawHref.trim();
                if (
                    !trimmedHref ||
                    trimmedHref.startsWith('#') ||
                    relativeLinkProtocolRelativePattern.test(trimmedHref) ||
                    relativeLinkSchemePattern.test(trimmedHref) ||
                    trimmedHref.startsWith('/')
                ) {
                    return null;
                }

                let resolvedHref = trimmedHref;
                const walker = relativeLinkBaseWalker;

                if (walker && typeof walker.walkTokens === 'function') {
                    const tempToken = { type: tokenType, href: trimmedHref };
                    try {
                        walker.walkTokens(tempToken);
                        resolvedHref = tempToken.href;
                    } catch (error) {
                        console.warn('marked-base-url resolution failed', error);
                        resolvedHref = fallbackResolveRelativeHref(trimmedHref);
                    }
                } else {
                    resolvedHref = fallbackResolveRelativeHref(trimmedHref);
                }

                const parts = splitResolvedHref(resolvedHref);
                if (!parts.filePath) {
                    return null;
                }

                if (tokenType === 'image') {
                    return {
                        assetHref: `${encodePathSegments(parts.filePath)}${parts.search}${parts.hash}`,
                    };
                }

                return {
                    fileTarget: `${parts.filePath}${parts.search}`,
                    hash: parts.hash,
                };
            }

            const relativeLinkExtension = {
                walkTokens(token) {
                    if (!token || typeof token.href !== 'string') {
                        return;
                    }

                    if (token.type === 'image') {
                        const asset = transformRelativeAsset(token.href, 'image');
                        if (asset && asset.assetHref) {
                            token.href = asset.assetHref;
                        }
                        return;
                    }

                    if (token.type !== 'link') {
                        return;
                    }

                    const result = transformRelativeAsset(token.href, 'link');
                    if (!result || !result.fileTarget) {
                        return;
                    }

                    const basePathname = typeof window !== 'undefined' && window.location ? window.location.pathname : '';
                    const query = buildQuery({ file: result.fileTarget });
                    token.href = `${basePathname}${query}${result.hash || ''}`;
                },
            };

            function getCssNumber(variableName, fallback) {
                if (typeof variableName !== 'string' || !variableName) {
                    return typeof fallback === 'number' ? fallback : 0;
                }

                try {
                    const computed = getComputedStyle(rootElement).getPropertyValue(variableName);
                    const parsed = Number.parseFloat(computed);
                    if (Number.isFinite(parsed)) {
                        return parsed;
                    }
                } catch (error) {
                    console.warn('Failed to read CSS variable', variableName, error);
                }

                return typeof fallback === 'number' ? fallback : 0;
            }

            function configureMarked() {
                if (typeof marked === 'undefined' || markedConfigured) {
                    return;
                }

                marked.use({
                    walkTokens(token) {
                        if (!token || token.type !== 'code') {
                            return;
                        }

                        const language = typeof token.lang === 'string' ? token.lang.toLowerCase() : '';
                        const source = token.text || token.raw || '';

                        if (language.includes('mermaid')) {
                            const id = `mermaid-diagram-${mermaidIdCounter++}`;
                            const encodedSource = encodeMermaidSource(source);
                            const mermaidHtml = `<div class="mermaid" id="${id}" data-mermaid-source="${encodedSource}"></div>`;
                            token.type = 'html';
                            token.raw = mermaidHtml;
                            token.text = mermaidHtml;
                            return;
                        }

                        if (language.includes('vega-lite') || language === 'vega') {
                            const id = `vega-diagram-${vegaIdCounter++}`;
                            const encodedSource = encodeVegaSource(source);
                            const vegaHtml = `<div class="vega-diagram" id="${id}" data-vega-source="${encodedSource}"></div>`;
                            token.type = 'html';
                            token.raw = vegaHtml;
                            token.text = vegaHtml;
                            return;
                        }

                        if (language.includes('excalidraw')) {
                            const id = `excalidraw-diagram-${excalidrawIdCounter++}`;
                            const encodedSource = encodeExcalidrawSource(source);
                            const excalidrawHtml = `<div class="excalidraw-diagram" id="${id}" data-excalidraw-source="${encodedSource}"></div>`;
                            token.type = 'html';
                            token.raw = excalidrawHtml;
                            token.text = excalidrawHtml;
                        }
                    },
                });

                marked.use({
                    headerIds: true,
                    mangle: false,
                    renderer: {
                        heading({ text, depth, raw }) {
                            const headingLevel = Math.min(Math.max(depth || 1, 1), 6);

                            // Create slug from the raw text or the rendered text
                            const sourceText = typeof raw === 'string' ? raw : text;
                            const slug = createSlug(sourceText);
                            const plainText = normaliseHeadingText(text, raw);
                            const ariaSource = plainText || (typeof raw === 'string' ? raw : 'heading');
                            const ariaLabel = escapeHtml(`Link to section ${ariaSource}`);
                            const headingLabel = plainText || ariaSource || 'this section';
                            const safeSlug = escapeHtml(slug);
                            const actionsAriaLabel = escapeHtml(`Section actions for ${headingLabel}`);
                            const editLabel = escapeHtml(`Edit section "${headingLabel}" in the editor`);
                            const copyLabel = escapeHtml(`Copy link to section "${headingLabel}"`);

                            if (Array.isArray(activeHeadingCollection)) {
                                activeHeadingCollection.push({
                                    level: headingLevel,
                                    text: plainText || ariaSource,
                                    slug,
                                });
                            }

                            return `<h${headingLevel} id="${safeSlug}">${text}<span class="heading-actions" role="group" aria-label="${actionsAriaLabel}"><button type="button" class="heading-action-button heading-action-edit" data-heading-action="edit" data-heading-slug="${safeSlug}" title="${editLabel}"><i class="fa-solid fa-pen-to-square" aria-hidden="true"></i><span class="sr-only">${editLabel}</span></button><button type="button" class="heading-action-button heading-action-copy" data-heading-action="copy" data-heading-slug="${safeSlug}" title="${copyLabel}"><i class="fa-solid fa-link" aria-hidden="true"></i><span class="sr-only">${copyLabel}</span></button></span><a class="heading-anchor" href="#${safeSlug}" aria-label="${ariaLabel}"></a></h${headingLevel}>`;
                        },
                    },
                });

                marked.setOptions({
                    breaks: true,
                    gfm: true,
                    highlight(code, language) {
                        if (typeof hljs === 'undefined') {
                            return code;
                        }
                        try {
                            if (language && hljs.getLanguage(language)) {
                                return hljs.highlight(code, { language }).value;
                            }
                            return hljs.highlightAuto(code).value;
                        } catch (err) {
                            console.warn('Highlight.js failed to render a block', err);
                            return code;
                        }
                    },
                });

                if (!relativeLinkExtensionRegistered) {
                    marked.use(relativeLinkExtension);
                    relativeLinkExtensionRegistered = true;
                }

                markedConfigured = true;
            }

            function normaliseHeadingText(rendered, raw) {
                if (typeof rendered === 'string' && rendered.trim()) {
                    const temp = document.createElement('div');
                    temp.innerHTML = rendered;
                    const textContent = (temp.textContent || temp.innerText || '').trim();
                    if (textContent) {
                        return textContent;
                    }
                }

                if (typeof raw === 'string') {
                    const trimmed = raw.trim();
                    if (trimmed) {
                        return trimmed;
                    }
                }

                return '';
            }

            function escapeHtml(value) {
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function computeBaseSlug(text) {
                if (!text) {
                    return '';
                }

                const temp = document.createElement('div');
                temp.innerHTML = text;
                const cleanText = temp.textContent || temp.innerText || text;

                return cleanText
                    .toLowerCase()
                    .trim()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function createSlug(text) {
                let slug = computeBaseSlug(text);

                if (!slug) {
                    slug = 'heading';
                }

                if (documentSlugCounts) {
                    if (documentSlugCounts.has(slug)) {
                        const count = documentSlugCounts.get(slug) + 1;
                        documentSlugCounts.set(slug, count);
                        return `${slug}-${count}`;
                    }

                    documentSlugCounts.set(slug, 0);
                }

                return slug;
            }

            function captureHeadingLocations(markdownSource) {
                headingLocationMap = new Map();

                if (typeof markdownSource !== 'string' || !markdownSource) {
                    return;
                }

                const slugCounts = new Map();
                const lines = markdownSource.split(/\r?\n/);

                lines.forEach((line, index) => {
                    const match = line.match(/^(#{1,6})\s+(.*)$/);
                    if (!match) {
                        return;
                    }

                    const rawHeading = match[2].trim();
                    let baseSlug = computeBaseSlug(rawHeading);
                    if (!baseSlug) {
                        baseSlug = 'heading';
                    }

                    let slug = baseSlug;
                    if (slugCounts.has(baseSlug)) {
                        const count = slugCounts.get(baseSlug) + 1;
                        slugCounts.set(baseSlug, count);
                        slug = `${baseSlug}-${count}`;
                    } else {
                        slugCounts.set(baseSlug, 0);
                    }

                    headingLocationMap.set(slug, {
                        line: index,
                        column: 0,
                        level: match[1].length,
                        text: rawHeading,
                    });
                });
            }

            function clearEditorHeadingHighlight() {
                if (!editorInstance || headingHighlightLine === null) {
                    headingHighlightLine = null;
                    return;
                }

                try {
                    editorInstance.removeLineClass(headingHighlightLine, 'background', 'heading-target-line');
                } catch (error) {
                    console.warn('Failed to remove heading highlight', error);
                }

                headingHighlightLine = null;
            }

            function highlightEditorLine(lineNumber) {
                const editor = ensureEditorInstance();
                if (!editor || typeof editor.addLineClass !== 'function') {
                    return;
                }

                if (headingHighlightTimeout) {
                    window.clearTimeout(headingHighlightTimeout);
                    headingHighlightTimeout = null;
                }

                if (headingHighlightLine !== null) {
                    try {
                        editor.removeLineClass(headingHighlightLine, 'background', 'heading-target-line');
                    } catch (error) {
                        console.warn('Failed to clear previous heading highlight', error);
                    }
                }

                try {
                    editor.addLineClass(lineNumber, 'background', 'heading-target-line');
                    headingHighlightLine = lineNumber;
                } catch (error) {
                    console.warn('Failed to apply heading highlight', error);
                    headingHighlightLine = null;
                    return;
                }

                headingHighlightTimeout = window.setTimeout(() => {
                    const instance = ensureEditorInstance();
                    if (instance && headingHighlightLine !== null) {
                        try {
                            instance.removeLineClass(headingHighlightLine, 'background', 'heading-target-line');
                        } catch (error) {
                            console.warn('Failed to remove heading highlight after delay', error);
                        }
                    }
                    headingHighlightLine = null;
                    headingHighlightTimeout = null;
                }, 2000);
            }

            function handleHeadingActionClick(event) {
                const button = event.target.closest('.heading-action-button');
                if (!button) {
                    return;
                }

                if (!content || !content.contains(button)) {
                    return;
                }

                event.preventDefault();
                event.stopPropagation();

                const action = button.dataset.headingAction;
                const slug = button.dataset.headingSlug;

                if (!slug) {
                    return;
                }

                if (action === 'edit') {
                    jumpToHeadingInEditor(slug);
                    return;
                }

                if (action === 'copy') {
                    copyHeadingLink(slug);
                }
            }

            function jumpToHeadingInEditor(slug) {
                if (!slug) {
                    return;
                }

                if (!currentFile) {
                    setStatus('Open a markdown file to edit sections.');
                    return;
                }

                const focusEditorOnHeading = () => {
                    const editor = ensureEditorInstance();
                    if (!editor) {
                        setStatus('Editor resources are still loading. Please try again in a moment.');
                        return;
                    }

                    let location = headingLocationMap.get(slug);
                    if (!location) {
                        const source = typeof editor.getValue === 'function' ? editor.getValue() : currentContent;
                        captureHeadingLocations(source);
                        location = headingLocationMap.get(slug);
                    }

                    if (!location) {
                        setStatus('Unable to locate this section in the editor.');
                        return;
                    }

                    const targetPosition = { line: location.line, ch: location.column || 0 };

                    editor.operation(() => {
                        editor.setCursor(targetPosition);
                        const bottomLine = Math.min(editor.lineCount() - 1, targetPosition.line + 5);
                        editor.scrollIntoView({ from: targetPosition, to: { line: bottomLine, ch: 0 } }, 200);
                        editor.focus();
                    });

                    highlightEditorLine(location.line);
                    setStatus('Jumped to section in editor.');
                };

                if (!isEditing) {
                    enterEditMode();
                    window.setTimeout(focusEditorOnHeading, 120);
                    return;
                }

                if (isPreviewing) {
                    returnToCodeMode();
                    window.setTimeout(focusEditorOnHeading, 120);
                    return;
                }

                focusEditorOnHeading();
            }

            function copyHeadingLink(slug) {
                if (!slug) {
                    return;
                }

                const baseUrl = window.location.href.split('#')[0];
                const link = `${baseUrl}#${slug}`;

                const notifyFailure = (error) => {
                    if (error) {
                        console.warn('Failed to copy heading link', error);
                    }
                    setStatus(`Copy failed. Link: ${link}`);
                };

                const notifySuccess = () => {
                    setStatus('Copied link to clipboard.');
                };

                if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                    navigator.clipboard.writeText(link).then(notifySuccess).catch((error) => {
                        fallbackCopyLink(link, notifySuccess, () => notifyFailure(error));
                    });
                    return;
                }

                fallbackCopyLink(link, notifySuccess, notifyFailure);
            }

            function fallbackCopyLink(text, onSuccess, onFailure) {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.select();

                let succeeded = false;
                let lastError = null;
                try {
                    succeeded = document.execCommand('copy');
                } catch (error) {
                    lastError = error;
                }

                document.body.removeChild(textarea);

                if (succeeded) {
                    if (typeof onSuccess === 'function') {
                        onSuccess();
                    }
                    return;
                }

                if (typeof onFailure === 'function') {
                    onFailure(lastError);
                }
            }

            function encodeDiagramSource(code) {
                if (!code) {
                    return '';
                }
                const bytes = textEncoder.encode(code);
                let binary = '';
                bytes.forEach((byte) => {
                    binary += String.fromCharCode(byte);
                });
                return btoa(binary);
            }

            function decodeDiagramSource(encoded, label = 'diagram') {
                if (!encoded) {
                    return '';
                }
                try {
                    const bytes = Uint8Array.from(atob(encoded), (char) => char.charCodeAt(0));
                    return textDecoder.decode(bytes);
                } catch (error) {
                    console.warn(`Failed to decode ${label} source`, error);
                    return '';
                }
            }

            function encodeMermaidSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeMermaidSource(encoded) {
                return decodeDiagramSource(encoded, 'Mermaid');
            }

            function encodeVegaSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeVegaSource(encoded) {
                return decodeDiagramSource(encoded, 'Vega');
            }

            function encodeExcalidrawSource(code) {
                return encodeDiagramSource(code);
            }

            function decodeExcalidrawSource(encoded) {
                return decodeDiagramSource(encoded, 'Excalidraw');
            }

            function createExcalidrawViewerUiOptions() {
                return {
                    canvasActions: {
                        changeViewBackgroundColor: false,
                        clearCanvas: false,
                        export: false,
                        loadScene: false,
                        saveAsImage: false,
                        saveScene: false,
                        saveToActiveFile: false,
                        toggleTheme: false,
                        toggleShortcuts: false,
                        zoomIn: false,
                        zoomOut: false,
                        zoomToFit: false,
                        resetZoom: false,
                        pan: false,
                        viewMode: false,
                        zenMode: false,
                        gridMode: false,
                        stats: false,
                    },
                };
            }

            function waitForCoreLibraries(maxRetries = 80, interval = 100) {
                if (librariesReadyPromise) {
                    return librariesReadyPromise;
                }

                librariesReadyPromise = new Promise((resolve) => {
                    let attempts = 0;
                    const check = () => {
                        if (typeof marked !== 'undefined') {
                            resolve();
                            return;
                        }

                        if (attempts++ >= maxRetries) {
                            resolve();
                            return;
                        }

                        window.setTimeout(check, interval);
                    };

                    check();
                });

                return librariesReadyPromise;
            }

            const DIAGRAM_ICONS = {
                Mermaid: '📊',
                Vega: '📈',
                Excalidraw: '✏️',
            };

            function showDiagramStatus(element, type, message, source, variant) {
                const icon = DIAGRAM_ICONS[type] || 'ℹ️';
                const emphasised = variant === 'error' ? `<strong>${escapeHtml(message)}</strong>` : escapeHtml(message);
                const sourceMarkup = source ? `<pre>${escapeHtml(source)}</pre>` : '';
                element.innerHTML = `
                    <div class="diagram-loading">
                        ${icon} <strong>${escapeHtml(type)}</strong><br>
                        ${emphasised}
                        ${sourceMarkup}
                    </div>
                `;
            }

            function showDiagramLoading(element, type, source) {
                showDiagramStatus(element, type, `${type} renderer loading…`, source, 'loading');
            }

            function showDiagramError(element, type, message, source) {
                showDiagramStatus(element, type, `Error: ${message}`, source, 'error');
            }

            function cleanupExcalidrawRoots() {
                excalidrawRoots.forEach((record) => {
                    try {
                        if (record && typeof record.unmount === 'function') {
                            record.unmount();
                        } else if (record && record.root && typeof record.root.unmount === 'function') {
                            record.root.unmount();
                        }
                    } catch (error) {
                        console.warn('Failed to unmount Excalidraw root', error);
                    }
                });
                excalidrawRoots.clear();
            }

            function scheduleMermaidRetry() {
                if (mermaidRetryTimer) {
                    return;
                }
                mermaidRetryTimer = window.setTimeout(() => {
                    mermaidRetryTimer = null;
                    renderMermaidDiagrams();
                }, 400);
            }

            function scheduleVegaRetry() {
                if (vegaRetryTimer) {
                    return;
                }
                vegaRetryTimer = window.setTimeout(() => {
                    vegaRetryTimer = null;
                    renderVegaVisualizations();
                }, 400);
            }

            function scheduleExcalidrawRetry() {
                if (excalidrawRetryTimer) {
                    return;
                }
                excalidrawRetryTimer = window.setTimeout(() => {
                    excalidrawRetryTimer = null;
                    renderExcalidrawDiagrams();
                }, 400);
            }

            function handleExcalidrawResize() {
                excalidrawRoots.forEach((record) => {
                    if (record && record.api) {
                        fitExcalidrawToViewport(record.api);
                    }
                });
            }

            function ensureExcalidrawResizeHandler() {
                if (excalidrawResizeHandlerAttached) {
                    return;
                }
                if (typeof window === 'undefined' || typeof window.addEventListener !== 'function') {
                    return;
                }
                window.addEventListener('resize', handleExcalidrawResize);
                excalidrawResizeHandlerAttached = true;
            }

            function fitExcalidrawToViewport(api) {
                if (!api || typeof api.getSceneElements !== 'function' || typeof api.scrollToContent !== 'function') {
                    return;
                }

                let elements;
                try {
                    elements = api.getSceneElements();
                } catch (error) {
                    console.warn('Failed to read Excalidraw scene elements', error);
                    return;
                }

                if (!Array.isArray(elements) || !elements.length) {
                    return;
                }

                const visibleElements = elements.filter((item) => item && !item.isDeleted);
                if (!visibleElements.length) {
                    return;
                }

                const executeFit = () => {
                    try {
                        api.scrollToContent(visibleElements, { fitToViewport: true, animate: false });
                    } catch (error) {
                        if (!excalidrawFitFailureLogged) {
                            console.warn('Failed to fit Excalidraw content', error);
                            excalidrawFitFailureLogged = true;
                        }
                    }
                };

                if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
                    window.requestAnimationFrame(executeFit);
                } else {
                    executeFit();
                }

                if (typeof window !== 'undefined' && typeof window.setTimeout === 'function') {
                    window.setTimeout(executeFit, 150);
                }
            }

            function renderMermaidDiagrams() {
                const diagrams = content.querySelectorAll('.mermaid[data-mermaid-source]');
                if (!diagrams.length) {
                    return;
                }

                if (typeof mermaid === 'undefined' || typeof mermaid.render !== 'function') {
                    diagrams.forEach((element) => {
                        const source = decodeMermaidSource(element.dataset.mermaidSource);
                        showDiagramLoading(element, 'Mermaid', source);
                    });
                    scheduleMermaidRetry();
                    return;
                }

                if (!mermaidInitAttempted) {
                    try {
                        mermaid.initialize({
                            startOnLoad: false,
                            theme: 'dark',
                            securityLevel: 'loose',
                        });
                    } catch (error) {
                        console.warn('Mermaid initialization issue', error);
                    }
                    mermaidInitAttempted = true;
                }

                diagrams.forEach((element, index) => {
                    const source = decodeMermaidSource(element.dataset.mermaidSource);
                    if (!source.trim()) {
                        showDiagramError(element, 'Mermaid', 'Diagram source is empty', source);
                        return;
                    }

                    const renderId = `${element.id || 'mermaid-diagram'}-${index}`;
                    mermaid
                        .render(renderId, source)
                        .then(({ svg }) => {
                            element.innerHTML = svg;
                        })
                        .catch((error) => {
                            console.error('Mermaid rendering error', error);
                            showDiagramError(element, 'Mermaid', error.message, source);
                        });
                });
            }

            function renderVegaVisualizations() {
                const diagrams = content.querySelectorAll('.vega-diagram[data-vega-source]');
                if (!diagrams.length) {
                    return;
                }

                if (typeof vegaEmbed === 'undefined') {
                    diagrams.forEach((element) => {
                        const source = decodeVegaSource(element.dataset.vegaSource);
                        showDiagramLoading(element, 'Vega', source);
                    });
                    scheduleVegaRetry();
                    return;
                }

                diagrams.forEach((element) => {
                    const source = decodeVegaSource(element.dataset.vegaSource);
                    if (!source.trim()) {
                        showDiagramError(element, 'Vega', 'Specification is empty', source);
                        return;
                    }

                    let spec;
                    try {
                        spec = JSON.parse(source);
                    } catch (error) {
                        console.error('Vega parsing error', error);
                        showDiagramError(element, 'Vega', 'Invalid Vega/Vega-Lite specification', source);
                        return;
                    }

                    element.innerHTML = '';
                    vegaEmbed(element, spec, { actions: false, renderer: 'canvas', theme: 'dark' }).catch((error) => {
                        console.error('Vega rendering error', error);
                        showDiagramError(element, 'Vega', error.message, source);
                    });
                });
            }

            function renderExcalidrawDiagrams() {
                const diagrams = content.querySelectorAll('.excalidraw-diagram[data-excalidraw-source]');
                if (!diagrams.length) {
                    return;
                }

                if (
                    !window.React ||
                    !window.ReactDOM ||
                    !window.ExcalidrawLib ||
                    !window.ExcalidrawLib.Excalidraw
                ) {
                    diagrams.forEach((element) => {
                        const source = decodeExcalidrawSource(element.dataset.excalidrawSource);
                        showDiagramLoading(element, 'Excalidraw', source);
                    });
                    scheduleExcalidrawRetry();
                    return;
                }

                diagrams.forEach((element) => {
                    const source = decodeExcalidrawSource(element.dataset.excalidrawSource);
                    if (!source.trim()) {
                        showDiagramError(element, 'Excalidraw', 'Scene data is empty', source);
                        return;
                    }

                    let sceneData;
                    try {
                        sceneData = JSON.parse(source);
                    } catch (error) {
                        console.error('Excalidraw parsing error', error);
                        showDiagramError(element, 'Excalidraw', 'Invalid scene JSON', source);
                        return;
                    }

                    const desiredBackground = 'transparent';
                    sceneData = {
                        ...sceneData,
                        appState: {
                            ...(sceneData && typeof sceneData === 'object' && sceneData.appState
                                ? sceneData.appState
                                : {}),
                            viewBackgroundColor: desiredBackground,
                        },
                    };

                    const existingRoot = excalidrawRoots.get(element);
                    if (existingRoot && typeof existingRoot.unmount === 'function') {
                        try {
                            existingRoot.unmount();
                        } catch (error) {
                            console.warn('Failed to unmount previous Excalidraw root', error);
                        }
                    }
                    excalidrawRoots.delete(element);

                    element.innerHTML = '';
                    const wrapper = document.createElement('div');
                    wrapper.className = 'excalidraw-wrapper';
                    wrapper.tabIndex = -1;
                    element.appendChild(wrapper);

                    const record = {
                        root: null,
                        api: null,
                        wrapper,
                        unmount() {
                            record.api = null;
                            if (record.root && typeof record.root.unmount === 'function') {
                                record.root.unmount();
                            } else if (
                                typeof window.ReactDOM !== 'undefined' &&
                                typeof window.ReactDOM.unmountComponentAtNode === 'function'
                            ) {
                                try {
                                    window.ReactDOM.unmountComponentAtNode(wrapper);
                                } catch (error) {
                                    console.warn('Failed to unmount Excalidraw instance', error);
                                }
                            }
                        },
                    };

                    try {
                        const viewerUiOptions = createExcalidrawViewerUiOptions();
                        const excalidrawElement = window.React.createElement(window.ExcalidrawLib.Excalidraw, {
                            initialData: sceneData,
                            viewModeEnabled: true,
                            zenModeEnabled: false,
                            gridModeEnabled: false,
                            theme: 'dark',
                            autoFocus: false,
                            UIOptions: viewerUiOptions,
                            handleKeyboardEvent: () => false,
                            ref: (api) => {
                                record.api = api || null;
                                if (api) {
                                    excalidrawFitFailureLogged = false;
                                    ensureExcalidrawResizeHandler();
                                    fitExcalidrawToViewport(api);
                                    if (typeof window !== 'undefined' && typeof window.setTimeout === 'function') {
                                        window.setTimeout(() => fitExcalidrawToViewport(api), 250);
                                    }
                                }
                            },
                        });

                        let root;
                        if (typeof window.ReactDOM.createRoot === 'function') {
                            root = window.ReactDOM.createRoot(wrapper);
                            root.render(excalidrawElement);
                        } else if (typeof window.ReactDOM.render === 'function') {
                            window.ReactDOM.render(excalidrawElement, wrapper);
                            root = {
                                unmount() {
                                    if (typeof window.ReactDOM.unmountComponentAtNode === 'function') {
                                        window.ReactDOM.unmountComponentAtNode(wrapper);
                                    }
                                },
                            };
                        } else {
                            throw new Error('ReactDOM renderer is unavailable');
                        }

                        record.root = root;
                        excalidrawRoots.set(element, record);
                    } catch (error) {
                        record.api = null;
                        console.error('Excalidraw rendering error', error);
                        showDiagramError(element, 'Excalidraw', error.message, source);
                    }
                });
            }

            function renderAllDiagrams() {
                renderMermaidDiagrams();
                renderVegaVisualizations();
                renderExcalidrawDiagrams();
            }

            function setStatus(message) {
                statusMessage.textContent = message || '';
            }

            function setConnectionStatus(connected) {
                offlineOverlay.classList.toggle('visible', !connected);
            }

            function setHasPendingChanges(value) {
                const nextValue = Boolean(value);
                if (nextValue === hasPendingChanges) {
                    return;
                }
                hasPendingChanges = nextValue;
                document.body.classList.toggle('document-has-pending-changes', hasPendingChanges);
                updateHeader();
            }

            function updateDocumentPanelTitle() {
                const viewerPanel = dockviewSetup?.panels?.viewer;
                if (!viewerPanel) {
                    return;
                }

                const baseTitle = currentFile || 'Document';
                const title = hasPendingChanges && currentFile ? `${baseTitle} ●` : baseTitle;
                const panelApi = viewerPanel?.api;

                if (panelApi && typeof panelApi.setTitle === 'function') {
                    panelApi.setTitle(title);
                } else if (typeof viewerPanel.setTitle === 'function') {
                    viewerPanel.setTitle(title);
                }
            }

            function promptUnsavedChanges(context = {}) {
                if (!unsavedChangesModal) {
                    return Promise.resolve('cancel');
                }

                if (activeUnsavedPrompt) {
                    return activeUnsavedPrompt;
                }

                const nextFile = typeof context.nextFile === 'string' ? context.nextFile : '';
                const displayName = currentFile || 'this document';
                if (unsavedChangesFilename) {
                    unsavedChangesFilename.textContent = displayName;
                }
                if (unsavedChangesMessage) {
                    unsavedChangesMessage.setAttribute('data-current-file', displayName);
                }
                if (unsavedChangesDetail) {
                    if (nextFile && nextFile !== currentFile) {
                        unsavedChangesDetail.textContent = `Switch to “${nextFile}” without saving?`;
                    } else {
                        unsavedChangesDetail.textContent = 'What would you like to do?';
                    }
                }

                unsavedChangesModal.classList.add('visible');
                document.body.classList.add('modal-open');

                const promise = new Promise((resolve) => {
                    const cleanup = () => {
                        unsavedChangesModal.classList.remove('visible');
                        document.body.classList.remove('modal-open');
                        if (unsavedChangesSaveButton) {
                            unsavedChangesSaveButton.removeEventListener('click', onSave);
                        }
                        if (unsavedChangesDiscardButton) {
                            unsavedChangesDiscardButton.removeEventListener('click', onDiscard);
                        }
                        if (unsavedChangesCancelButton) {
                            unsavedChangesCancelButton.removeEventListener('click', onCancel);
                        }
                        unsavedChangesModal.removeEventListener('keydown', onKeyDown, true);
                        unsavedChangesModal.removeEventListener('click', onOverlayClick);
                        activeUnsavedPrompt = null;
                    };

                    const choose = (result) => {
                        cleanup();
                        resolve(result);
                    };

                    const onSave = () => choose('save');
                    const onDiscard = () => choose('discard');
                    const onCancel = () => choose('cancel');
                    const onKeyDown = (event) => {
                        if (event.key === 'Escape') {
                            event.preventDefault();
                            choose('cancel');
                        }
                    };
                    const onOverlayClick = (event) => {
                        if (event.target === unsavedChangesModal) {
                            choose('cancel');
                        }
                    };

                    if (unsavedChangesSaveButton) {
                        unsavedChangesSaveButton.addEventListener('click', onSave);
                    }
                    if (unsavedChangesDiscardButton) {
                        unsavedChangesDiscardButton.addEventListener('click', onDiscard);
                    }
                    if (unsavedChangesCancelButton) {
                        unsavedChangesCancelButton.addEventListener('click', onCancel);
                    }

                    unsavedChangesModal.addEventListener('keydown', onKeyDown, true);
                    unsavedChangesModal.addEventListener('click', onOverlayClick);

                    window.setTimeout(() => {
                        if (typeof unsavedChangesSaveButton?.focus === 'function') {
                            unsavedChangesSaveButton.focus();
                        } else if (typeof unsavedChangesDiscardButton?.focus === 'function') {
                            unsavedChangesDiscardButton.focus();
                        } else {
                            unsavedChangesModal.focus({ preventScroll: true });
                        }
                    }, 0);
                });

                activeUnsavedPrompt = promise;
                return promise;
            }

            function updateHeader() {
                const hasFile = Boolean(currentFile);
                const indicator = hasPendingChanges && hasFile ? ' ●' : '';

                if (fileName) {
                    if (dockviewIsActive) {
                        if (hasFile) {
                            fileName.textContent = `Markdown Viewer${indicator}`;
                            fileName.classList.add('hidden');
                        } else {
                            fileName.textContent = 'No file selected';
                            fileName.classList.remove('hidden');
                        }
                    } else {
                        fileName.classList.remove('hidden');
                        const baseName = hasFile ? currentFile : 'No file selected';
                        fileName.textContent = hasFile ? `${baseName}${indicator}` : baseName;
                    }
                }

                sidebarPath.textContent = resolvedRootPath || originalPathArgument || 'Unknown';
                downloadButton.disabled = !hasFile;
                deleteButton.disabled = !hasFile;
                editButton.disabled = !hasFile && !isEditing;
                previewButton.disabled = !hasFile;
                saveButton.disabled = !hasFile;
                cancelButton.disabled = false;
                updateActionVisibility();
                updateDocumentPanelTitle();
            }

            function updateActionVisibility() {
                const hasFile = Boolean(currentFile);
                editButton.classList.toggle('hidden', !hasFile || (isEditing && !isPreviewing));
                previewButton.classList.toggle('hidden', !isEditing || isPreviewing);
                saveButton.classList.toggle('hidden', !isEditing);
                cancelButton.classList.toggle('hidden', !isEditing);
                downloadButton.classList.toggle('hidden', isEditing);
                deleteButton.classList.toggle('hidden', isEditing);
            }

            function buildQuery(params) {
                const query = new URLSearchParams();
                if (originalPathArgument) {
                    query.set('path', originalPathArgument);
                }
                Object.entries(params).forEach(([key, value]) => {
                    if (value !== undefined && value !== null && value !== '') {
                        query.set(key, value);
                    }
                });
                const queryString = query.toString();
                return queryString ? `?${queryString}` : '';
            }

            function updateLocation(file, { replace = false } = {}) {
                const newQuery = buildQuery({ file });
                const newUrl = `${window.location.pathname}${newQuery}`;
                const currentUrl = `${window.location.pathname}${window.location.search}`;
                const stateData = { file };

                if (replace || newUrl === currentUrl) {
                    window.history.replaceState(stateData, '', newUrl);
                } else {
                    window.history.pushState(stateData, '', newUrl);
                }
            }

            function fileFromSearch(search) {
                const params = new URLSearchParams(search || '');
                const value = params.get('file');
                if (typeof value !== 'string') {
                    return '';
                }
                const trimmed = value.trim();
                return trimmed === '' ? '' : trimmed;
            }

            function renderMarkdown(markdownText, options = {}) {
                cleanupExcalidrawRoots();
                configureMarked();
                updateRelativeLinkBase(currentFile);
                mermaidIdCounter = 0;
                vegaIdCounter = 0;
                excalidrawIdCounter = 0;

                // Reset slug counter for each document to ensure unique IDs
                documentSlugCounts = new Map();

                const sourceText = markdownText || '';
                const updateCurrent = Boolean(options.updateCurrent);
                captureHeadingLocations(sourceText);

                if (typeof marked === 'undefined') {
                    activeHeadingCollection = null;
                    pendingMarkdown = sourceText;
                    content.textContent = sourceText;
                    updateTableOfContents([]);
                    waitForCoreLibraries().then(() => {
                        if (pendingMarkdown !== null) {
                            const textToRender = pendingMarkdown;
                            pendingMarkdown = null;
                            renderMarkdown(textToRender, { updateCurrent });
                        }
                    });
                    if (updateCurrent) {
                        currentContent = sourceText;
                    }
                    return;
                }

                activeHeadingCollection = [];
                content.innerHTML = marked.parse(sourceText);
                const headings = Array.isArray(activeHeadingCollection) ? [...activeHeadingCollection] : [];
                activeHeadingCollection = null;
                pendingMarkdown = null;

                if (typeof hljs !== 'undefined') {
                    content.querySelectorAll('pre code').forEach((block) => {
                        if (block.closest('.mermaid, .vega-diagram, .excalidraw-diagram')) {
                            return;
                        }
                        try {
                            hljs.highlightElement(block);
                        } catch (err) {
                            console.warn('Highlight.js error', err);
                        }
                    });
                }

                updateTableOfContents(headings);
                renderAllDiagrams();
                if (updateCurrent) {
                    currentContent = sourceText;
                }
            }

            function updateTableOfContents(headings) {
                if (!tocList) {
                    return;
                }

                tocList.innerHTML = '';

                if (!Array.isArray(headings) || headings.length === 0) {
                    const emptyState = document.createElement('p');
                    emptyState.className = 'toc-empty-state';
                    emptyState.textContent = 'No headings found in this document yet.';
                    tocList.appendChild(emptyState);
                    return;
                }

                const minLevel = headings.reduce((accumulator, entry) => {
                    const level = typeof entry.level === 'number' ? entry.level : 1;
                    return Math.min(accumulator, Math.max(1, Math.min(6, level)));
                }, 6);

                const list = document.createElement('ol');
                list.setAttribute('role', 'list');

                headings.forEach((entry) => {
                    const level = Math.max(1, Math.min(6, entry.level || 1));
                    const item = document.createElement('li');
                    item.className = 'toc-entry';

                    const link = document.createElement('a');
                    link.className = 'toc-link';
                    link.href = `#${entry.slug}`;
                    link.textContent = entry.text || entry.slug || 'Untitled section';
                    link.setAttribute('aria-level', String(level));
                    link.dataset.level = String(level);
                    const indentLevel = Math.max(0, level - minLevel);
                    link.style.paddingLeft = `${10 + indentLevel * 16}px`;

                    item.appendChild(link);
                    list.appendChild(item);
                });

                tocList.appendChild(list);
            }

            function handleTocClick(event) {
                const link = event.target.closest('a.toc-link');
                if (!link) {
                    return;
                }

                const hash = link.getAttribute('href');
                if (typeof hash !== 'string' || !hash.startsWith('#')) {
                    return;
                }

                const targetId = hash.slice(1);
                if (!targetId) {
                    return;
                }

                const targetElement = document.getElementById(targetId);
                if (!targetElement) {
                    return;
                }

                event.preventDefault();

                try {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } catch (error) {
                    targetElement.scrollIntoView();
                }

                if (typeof history !== 'undefined' && typeof history.replaceState === 'function') {
                    const newUrl = `${window.location.pathname}${window.location.search}#${targetId}`;
                    history.replaceState(history.state, '', newUrl);
                }
            }

            if (tocList) {
                tocList.addEventListener('click', handleTocClick);
            }

            // ------------------------------------------------------------------
            // Markdown editing helpers
            // ------------------------------------------------------------------
            function ensureEditorInstance() {
                if (editorInstance) {
                    return editorInstance;
                }
                if (typeof window.CodeMirror === 'undefined') {
                    return null;
                }

                editorContainer.innerHTML = '';
                suppressEditorChangeEvents = true;
                try {
                    editorInstance = window.CodeMirror(editorContainer, {
                        value: draftContent,
                        mode: 'markdown',
                        theme: 'one-dark',
                        lineNumbers: true,
                        lineWrapping: true,
                        autofocus: true,
                    });
                    editorInstance.setSize('100%', '100%');
                    editorInstance.on('change', handleEditorContentChange);
                } finally {
                    suppressEditorChangeEvents = false;
                }
                setHasPendingChanges(draftContent !== currentContent);
                return editorInstance;
            }

            function handleEditorContentChange(instance) {
                if (!instance || suppressEditorChangeEvents) {
                    return;
                }
                draftContent = instance.getValue();
                setHasPendingChanges(draftContent !== currentContent);
            }

            function enterEditMode() {
                if (!currentFile) {
                    return;
                }
                if (typeof window.CodeMirror === 'undefined') {
                    setStatus('Editor resources are still loading. Please try again in a moment.');
                    return;
                }

                isEditing = true;
                isPreviewing = false;
                draftContent = currentContent;
                const editor = ensureEditorInstance();
                if (!editor) {
                    isEditing = false;
                    setStatus('Editor resources are still loading. Please try again in a moment.');
                    updateActionVisibility();
                    return;
                }

                suppressEditorChangeEvents = true;
                try {
                    editor.setValue(draftContent);
                } finally {
                    suppressEditorChangeEvents = false;
                }
                setHasPendingChanges(false);
                window.setTimeout(() => {
                    editor.refresh();
                    editor.focus();
                }, 0);

                content.classList.add('hidden');
                editorContainer.classList.add('visible');
                updateHeader();
                setStatus('Editing markdown…');
            }

            function enterPreviewMode() {
                if (!isEditing) {
                    return;
                }
                const editor = ensureEditorInstance();
                if (editor) {
                    draftContent = editor.getValue();
                }
                setHasPendingChanges(draftContent !== currentContent);
                isPreviewing = true;
                renderMarkdown(draftContent, { updateCurrent: false });
                editorContainer.classList.remove('visible');
                content.classList.remove('hidden');
                updateHeader();
                setStatus('Previewing changes.');
            }

            function returnToCodeMode() {
                if (!isPreviewing) {
                    return;
                }
                isPreviewing = false;
                renderMarkdown(currentContent, { updateCurrent: true });
                content.classList.add('hidden');
                editorContainer.classList.add('visible');
                const editor = ensureEditorInstance();
                if (editor) {
                    window.setTimeout(() => {
                        editor.refresh();
                        editor.focus();
                    }, 0);
                }
                updateHeader();
                setStatus('Editing markdown…');
            }

            function exitEditMode(options = {}) {
                const { restoreContent = true } = options;
                if (!isEditing && !isPreviewing) {
                    updateHeader();
                    return;
                }
                isEditing = false;
                isPreviewing = false;
                draftContent = '';
                clearEditorHeadingHighlight();
                content.classList.remove('hidden');
                editorContainer.classList.remove('visible');
                if (restoreContent) {
                    renderMarkdown(currentContent, { updateCurrent: true });
                }
                setHasPendingChanges(false);
                updateHeader();
            }


            function resetViewToFallback(options = {}) {
                const { skipHistory = false } = options;
                exitEditMode({ restoreContent: false });
                currentFile = null;
                const fallback = fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path');
                renderMarkdown(fallback, { updateCurrent: true });
                updateActiveFileHighlight();
                updateHeader();
                if (!skipHistory) {
                    updateLocation('', { replace: true });
                }
            }
            function renderFileList() {
                fileList.innerHTML = '';

                const treeToRender = Array.isArray(fileTree) && fileTree.length
                    ? fileTree
                    : buildTreeFromFlatList(files);

                if (!treeToRender.length) {
                    const empty = document.createElement('li');
                    empty.className = 'empty-state';
                    empty.textContent = 'No markdown files yet';
                    fileList.appendChild(empty);
                    return;
                }

                ensureExpandedForCurrentFile(currentFile);

                const visited = new Set();
                const fragment = document.createDocumentFragment();
                treeToRender.forEach((node) => {
                    fragment.appendChild(renderTreeNode(node, 0, visited));
                });
                fileList.appendChild(fragment);

                const stale = [];
                expandedDirectories.forEach((value) => {
                    if (!visited.has(value)) {
                        stale.push(value);
                    }
                });
                stale.forEach((value) => expandedDirectories.delete(value));

                knownDirectories.clear();
                visited.forEach((value) => knownDirectories.add(value));

                updateActiveFileHighlight();
            }

            function renderTreeNode(node, depth, visited) {
                const item = document.createElement('li');
                item.className = `tree-node ${node.type === 'directory' ? 'directory-node' : 'file-node'}`;

                if (node.type === 'directory') {
                    const pathKey = typeof node.relativePath === 'string' ? node.relativePath : '';
                    visited.add(pathKey);

                    if (!knownDirectories.has(pathKey) && !expandedDirectories.has(pathKey)) {
                        expandedDirectories.add(pathKey);
                    }

                    const row = document.createElement('div');
                    row.className = 'tree-row directory-row';
                    row.style.paddingLeft = `${depth * 16}px`;

                    const isExpanded = expandedDirectories.has(pathKey);
                    const toggle = document.createElement('button');
                    toggle.type = 'button';
                    toggle.className = 'tree-toggle';
                    toggle.setAttribute('aria-expanded', String(isExpanded));
                    toggle.setAttribute('aria-label', `${isExpanded ? 'Collapse' : 'Expand'} ${node.name}`);
                    toggle.textContent = isExpanded ? '▾' : '▸';
                    toggle.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        toggleDirectory(pathKey);
                    });

                    const label = document.createElement('button');
                    label.type = 'button';
                    label.className = 'tree-label directory-label';

                    // Create folder icon element
                    const folderIcon = document.createElement('i');
                    folderIcon.className = isExpanded ? 'directory-icon fas fa-folder-open' : 'directory-icon fas fa-folder';

                    // Create text element
                    const labelText = document.createElement('span');
                    labelText.textContent = node.name;

                    // Append icon and text to label
                    label.appendChild(folderIcon);
                    label.appendChild(labelText);

                    label.addEventListener('click', (event) => {
                        event.preventDefault();
                        toggleDirectory(pathKey);
                    });

                    row.appendChild(toggle);
                    row.appendChild(label);
                    item.appendChild(row);

                    const childrenList = document.createElement('ul');
                    childrenList.className = 'tree-children';
                    if (!isExpanded) {
                        childrenList.classList.add('collapsed');
                    }
                    const children = Array.isArray(node.children) ? node.children : [];
                    children.forEach((child) => {
                        childrenList.appendChild(renderTreeNode(child, depth + 1, visited));
                    });
                    item.appendChild(childrenList);
                    return item;
                }

                const button = document.createElement('button');
                button.className = 'file-button';
                button.type = 'button';

                // Create icon element
                const icon = document.createElement('i');
                icon.className = 'file-icon fab fa-markdown'; // Font Awesome markdown icon

                // Create text element
                const text = document.createElement('span');
                text.textContent = node.name;

                // Append icon and text to button
                button.appendChild(icon);
                button.appendChild(text);

                button.dataset.file = node.relativePath;
                button.style.paddingLeft = `${depth * 16 + 24}px`;
                button.addEventListener('click', () => {
                    if (node.relativePath !== currentFile) {
                        selectFile(node.relativePath);
                    }
                });
                item.appendChild(button);
                return item;
            }

            function ensureExpandedForCurrentFile(filePath) {
                if (typeof filePath !== 'string' || !filePath.includes('/')) {
                    return;
                }
                const parts = filePath.split('/');
                parts.pop();
                let prefix = '';
                parts.forEach((segment) => {
                    if (!segment) {
                        return;
                    }
                    prefix = prefix ? `${prefix}/${segment}` : segment;
                    expandedDirectories.add(prefix);
                });
            }

            function toggleDirectory(pathKey) {
                if (!pathKey && pathKey !== '') {
                    return;
                }
                if (expandedDirectories.has(pathKey)) {
                    expandedDirectories.delete(pathKey);
                } else {
                    expandedDirectories.add(pathKey);
                }
                renderFileList();
            }

            function updateActiveFileHighlight() {
                fileList.querySelectorAll('.file-button').forEach((button) => {
                    button.classList.toggle('active', button.dataset.file === currentFile);
                });
            }

            async function fetchJson(url, options) {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `Request failed with status ${response.status}`);
                }
                return response.json();
            }

            async function refreshFiles() {
                const url = `/api/files${buildQuery({})}`;
                const data = await fetchJson(url);
                resolvedRootPath = data.rootPath || resolvedRootPath;
                const updatedIndex = normaliseFileIndex({ filesValue: data.files, treeValue: data.tree });
                files = updatedIndex.files;
                fileTree = updatedIndex.tree;
                renderFileList();
                if (!files.find((entry) => entry.relativePath === currentFile)) {
                    currentFile = files.length ? files[0].relativePath : null;
                    if (currentFile) {
                        await loadFile(currentFile, { replaceHistory: true });
                    } else {
                        currentFile = null;
                        exitEditMode({ restoreContent: false });
                        renderMarkdown(
                            fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path'),
                            { updateCurrent: true }
                        );
                        updateLocation('', { replace: true });
                        updateHeader();
                    }
                } else {
                    updateActiveFileHighlight();
                    updateHeader();
                }
            }

            function fallbackMarkdownFor(path) {
                return `# No markdown files found\n\nThe directory \`${path}\` does not contain any markdown files yet.`;
            }

            async function loadFile(file, options = {}) {
                const { skipHistory = false, replaceHistory = false } = options;
                if (isEditing || isPreviewing) {
                    setStatus('Editing session closed because the file was reloaded.');
                    exitEditMode();
                } else {
                    setStatus('');
                }
                const url = `/api/file${buildQuery({ file })}`;
                try {
                    const data = await fetchJson(url);
                    resolvedRootPath = data.rootPath || resolvedRootPath;
                    currentFile = data.file || file;
                    renderMarkdown(data.content || '', { updateCurrent: true });
                    setHasPendingChanges(false);
                    updateActiveFileHighlight();
                    updateHeader();
                    updateLocation(currentFile, { replace: replaceHistory || skipHistory });
                } catch (err) {
                    setStatus(err.message);
                    console.error('Failed to load file', err);
                }
            }

            async function saveCurrentFile() {
                if (!isEditing || !currentFile) {
                    return false;
                }

                const editor = ensureEditorInstance();
                if (editor && !isPreviewing) {
                    draftContent = editor.getValue();
                }

                const contentToSave = draftContent;
                setStatus('Saving changes…');

                try {
                    await fetchJson(`/api/file${buildQuery({ file: currentFile })}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content: contentToSave }),
                    });
                    currentContent = contentToSave;
                    exitEditMode();
                    setStatus('Changes saved.');
                    updateActiveFileHighlight();
                    return true;
                } catch (err) {
                    setStatus(err.message);
                    console.error('Save failed', err);
                    return false;
                }
            }

            async function selectFile(file) {
                if (hasPendingChanges) {
                    const decision = await promptUnsavedChanges({ nextFile: file });
                    if (decision === 'cancel') {
                        return;
                    }
                    if (decision === 'save') {
                        const saved = await saveCurrentFile();
                        if (!saved) {
                            return;
                        }
                    } else if (decision === 'discard') {
                        exitEditMode();
                        setStatus('Changes discarded.');
                    }
                } else if (isEditing || isPreviewing) {
                    exitEditMode();
                }
                await loadFile(file);
            }

            function setupActions() {
                editButton.addEventListener('click', () => {
                    if (isEditing && isPreviewing) {
                        returnToCodeMode();
                        return;
                    }
                    if (!isEditing) {
                        enterEditMode();
                    }
                });

                previewButton.addEventListener('click', () => {
                    if (!currentFile) {
                        return;
                    }
                    enterPreviewMode();
                });

                cancelButton.addEventListener('click', () => {
                    if (!isEditing && !isPreviewing) {
                        return;
                    }
                    exitEditMode();
                    setStatus('Edits cancelled.');
                });

                saveButton.addEventListener('click', async () => {
                    await saveCurrentFile();
                });

                downloadButton.addEventListener('click', async () => {
                    if (!currentFile) {
                        return;
                    }
                    try {
                        const data = await fetchJson(`/api/file${buildQuery({ file: currentFile })}`);
                        const blob = new Blob([data.content || ''], { type: 'text/markdown' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = currentFile;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    } catch (err) {
                        setStatus(err.message);
                        console.error('Download failed', err);
                    }
                });

                deleteButton.addEventListener('click', async () => {
                    if (!currentFile) {
                        return;
                    }
                    const confirmed = window.confirm(`Delete ${currentFile}?`);
                    if (!confirmed) {
                        return;
                    }
                    try {
                        await fetchJson(`/api/file${buildQuery({ file: currentFile })}`, { method: 'DELETE' });
                        setStatus('File deleted.');
                        await refreshFiles();
                    } catch (err) {
                        setStatus(err.message);
                        console.error('Delete failed', err);
                    }
                });
            }

            function connectWebSocket() {
                if (websocket) {
                    websocket.close();
                }

                const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
                websocket = new WebSocket(`${protocol}://${window.location.host}/ws`);

                websocket.addEventListener('open', () => {
                    setConnectionStatus(true);
                    websocket.send(JSON.stringify({ type: 'subscribe', path: originalPathArgument }));
                });

                websocket.addEventListener('message', async (event) => {
                    try {
                        const payload = JSON.parse(event.data);
                        if (payload.type === 'directory_update') {
                            resolvedRootPath = payload.path || resolvedRootPath;
                            const updatedIndex = normaliseFileIndex({
                                filesValue: payload.files,
                                treeValue: payload.tree,
                            });
                            files = updatedIndex.files;
                            fileTree = updatedIndex.tree;
                            renderFileList();
                            if (!files.find((entry) => entry.relativePath === currentFile)) {
                                currentFile = files.length ? files[0].relativePath : null;
                                if (currentFile) {
                                    await loadFile(currentFile, { replaceHistory: true });
                                } else {
                                    currentFile = null;
                                    exitEditMode({ restoreContent: false });
                                    renderMarkdown(
                                        fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path'),
                                        { updateCurrent: true }
                                    );
                                    updateLocation('', { replace: true });
                                    updateHeader();
                                }
                            } else {
                                updateActiveFileHighlight();
                                updateHeader();
                            }
                        } else if (payload.type === 'file_changed') {
                            if (payload.file && payload.file === currentFile) {
                                await loadFile(currentFile, { replaceHistory: true });
                            }
                        }
                    } catch (err) {
                        console.error('Failed to process websocket event', err);
                    }
                });

                function scheduleReconnect() {
                    if (reconnectTimer) {
                        return;
                    }
                    reconnectTimer = window.setTimeout(() => {
                        reconnectTimer = null;
                        connectWebSocket();
                    }, 1500);
                }

                websocket.addEventListener('close', () => {
                    setConnectionStatus(false);
                    scheduleReconnect();
                });

                websocket.addEventListener('error', () => {
                    websocket.close();
                });
            }

            function scheduleTerminalLibraryRetry() {
                if (terminalLibraryRetryTimer) {
                    return;
                }
                terminalLibraryRetryTimer = window.setTimeout(() => {
                    terminalLibraryRetryTimer = null;
                    if (!terminalInstance) {
                        ensureTerminalInstance();
                    }
                    if (!terminalSocket) {
                        connectTerminal();
                    }
                }, 250);
            }

            function areTerminalLibrariesReady() {
                return (
                    typeof window !== 'undefined' &&
                    typeof window.Terminal === 'function' &&
                    window.FitAddon &&
                    typeof window.FitAddon.FitAddon === 'function'
                );
            }

            function ensureTerminalInstance() {
                if (terminalInstance || !terminalContainer) {
                    return terminalInstance;
                }

                if (!areTerminalLibrariesReady()) {
                    scheduleTerminalLibraryRetry();
                    return null;
                }

                try {
                    terminalInstance = new window.Terminal({
                        convertEol: true,
                        cursorBlink: true,
                        fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                        fontSize: 13,
                        theme: {
                            // Palette derived from the provided macOS Terminal profile to keep the
                            // in-browser terminal consistent with the requested look-and-feel.
                            background: '#21252b',
                            foreground: '#abb2bf',
                            cursor: '#abb2bf',
                            cursorAccent: '#21252b',
                            selection: '#323844',
                            selectionForeground: '#abb2bf',
                            black: '#21252b',
                            red: '#e06c75',
                            green: '#98c379',
                            yellow: '#e5c07b',
                            blue: '#61afef',
                            magenta: '#c678dd',
                            cyan: '#56b6c2',
                            white: '#abb2bf',
                            brightBlack: '#767676',
                            brightRed: '#e06c75',
                            brightGreen: '#98c379',
                            brightYellow: '#e5c07b',
                            brightBlue: '#61afef',
                            brightMagenta: '#c678dd',
                            brightCyan: '#56b6c2',
                            brightWhite: '#abb2bf',
                        },
                    });
                } catch (error) {
                    console.warn('Failed to initialise terminal instance', error);
                    terminalInstance = null;
                    return null;
                }

                try {
                    terminalFitAddon = new window.FitAddon.FitAddon();
                    terminalInstance.loadAddon(terminalFitAddon);
                } catch (error) {
                    console.warn('Failed to load terminal fit addon', error);
                    terminalInstance.dispose();
                    terminalInstance = null;
                    return null;
                }

                terminalInstance.open(terminalContainer);
                terminalInstance.focus();

                terminalInstance.onData((data) => {
                    if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                        terminalSocket.send(JSON.stringify({ type: 'input', data }));
                    }
                });

                terminalInstance.onResize((size) => {
                    if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                        terminalSocket.send(
                            JSON.stringify({ type: 'resize', cols: size.cols, rows: size.rows })
                        );
                    }
                });

                scheduleTerminalFit();
                return terminalInstance;
            }

            function scheduleTerminalFit() {
                if (!terminalInstance || !terminalFitAddon || terminalCollapsed) {
                    return;
                }

                if (pendingTerminalFitFrame) {
                    window.cancelAnimationFrame(pendingTerminalFitFrame);
                }

                pendingTerminalFitFrame = window.requestAnimationFrame(() => {
                    pendingTerminalFitFrame = null;
                    fitTerminal();
                });
            }

            function fitTerminal() {
                if (!terminalInstance || !terminalFitAddon || terminalCollapsed) {
                    return;
                }

                try {
                    terminalFitAddon.fit();
                } catch (error) {
                    console.warn('Unable to fit terminal to container', error);
                    return;
                }

                sendTerminalResize();
            }

            function sendTerminalResize() {
                if (!terminalInstance || !terminalSocket || terminalSocket.readyState !== WebSocket.OPEN) {
                    return;
                }
                terminalSocket.send(
                    JSON.stringify({ type: 'resize', cols: terminalInstance.cols, rows: terminalInstance.rows })
                );
            }

            function updateTerminalStatus(message) {
                if (terminalStatusText) {
                    terminalStatusText.textContent = message || '';
                }
                terminalLastStatusMessage = message || '';
            }

            function scheduleTerminalReconnect(delay = 1500) {
                if (terminalReconnectTimer) {
                    return;
                }
                terminalReconnectTimer = window.setTimeout(() => {
                    terminalReconnectTimer = null;
                    connectTerminal();
                }, delay);
            }

            function connectTerminal() {
                if (!terminalContainer) {
                    return;
                }

                if (terminalSocket &&
                    (terminalSocket.readyState === WebSocket.OPEN || terminalSocket.readyState === WebSocket.CONNECTING)) {
                    return;
                }

                const terminal = ensureTerminalInstance();
                if (!terminal) {
                    scheduleTerminalLibraryRetry();
                    return;
                }

                const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
                const socket = new WebSocket(`${protocol}://${window.location.host}/ws/terminal`);
                socket.binaryType = 'arraybuffer';
                terminalSocket = socket;
                updateTerminalStatus('Connecting…');

                socket.addEventListener('open', () => {
                    if (terminalReconnectTimer) {
                        window.clearTimeout(terminalReconnectTimer);
                        terminalReconnectTimer = null;
                    }
                    updateTerminalStatus('Connected');
                    scheduleTerminalFit();
                });

                socket.addEventListener('message', (event) => {
                    if (!terminalInstance) {
                        return;
                    }

                    if (typeof event.data === 'string') {
                        try {
                            const payload = JSON.parse(event.data);
                            if (payload.type === 'state' && typeof payload.message === 'string') {
                                updateTerminalStatus(payload.message);
                                return;
                            }
                            if (payload.type === 'exit') {
                                if (typeof payload.code === 'number') {
                                    updateTerminalStatus(`Process exited (${payload.code})`);
                                } else {
                                    updateTerminalStatus('Process exited');
                                }
                                scheduleTerminalReconnect();
                                return;
                            }
                        } catch (error) {
                            // Treat as raw output when parsing fails.
                            terminalInstance.write(event.data);
                            return;
                        }

                        terminalInstance.write(event.data);
                        return;
                    }

                    const consumeBuffer = (buffer) => {
                        if (!buffer) {
                            return;
                        }
                        const text = terminalDecoder.decode(buffer);
                        if (text) {
                            terminalInstance.write(text);
                        }
                    };

                    if (event.data instanceof ArrayBuffer) {
                        consumeBuffer(new Uint8Array(event.data));
                        return;
                    }

                    if (event.data && typeof event.data.arrayBuffer === 'function') {
                        event.data
                            .arrayBuffer()
                            .then((buffer) => consumeBuffer(new Uint8Array(buffer)))
                            .catch((error) => console.warn('Failed to decode terminal payload', error));
                    }
                });

                socket.addEventListener('close', () => {
                    terminalSocket = null;
                    if (!terminalLastStatusMessage.startsWith('Process exited')) {
                        updateTerminalStatus('Disconnected – reconnecting…');
                    }
                    scheduleTerminalReconnect();
                });

                socket.addEventListener('error', () => {
                    updateTerminalStatus('Connection error');
                    socket.close();
                });
            }

            function setupTerminalPanel() {
                if (!terminalPanel) {
                    return;
                }

                if (!dockviewIsActive && terminalResizeObserver) {
                    terminalResizeObserver.disconnect();
                    terminalResizeObserver = null;
                }

                if (dockviewIsActive) {
                    terminalCollapsed = false;
                    terminalPanel.style.height = '';
                    terminalPanel.style.maxHeight = '';
                    terminalPanel.classList.remove('is-collapsed');
                    if (terminalResizeHandle) {
                        terminalResizeHandle.remove();
                    }
                    if (terminalToggleButton) {
                        terminalToggleButton.disabled = true;
                        terminalToggleButton.textContent = 'Terminal (layout-managed)';
                        terminalToggleButton.setAttribute('aria-expanded', 'true');
                    }

                    if (!terminalResizeObserver && typeof window.ResizeObserver === 'function') {
                        const resizeTarget = terminalPanel.parentElement || terminalPanel;
                        if (resizeTarget) {
                            terminalResizeObserver = new window.ResizeObserver(() => {
                                scheduleTerminalFit();
                            });
                            terminalResizeObserver.observe(resizeTarget);
                        }
                    }

                    const instance = ensureTerminalInstance();
                    if (instance) {
                        scheduleTerminalFit();
                    }
                    connectTerminal();
                    return;
                }

                const minHeight = 140;

                const clampHeight = (value) => {
                    const max = Math.max(minHeight, Math.round(window.innerHeight * 0.75));
                    if (Number.isFinite(value)) {
                        return Math.min(Math.max(value, minHeight), max);
                    }
                    return minHeight;
                };

                const persistHeight = () => {
                    if (typeof window.localStorage === 'undefined') {
                        return;
                    }
                    try {
                        window.localStorage.setItem(terminalStorageKey, String(terminalHeight));
                    } catch (error) {
                        // Ignore persistence errors (e.g. storage disabled).
                    }
                };

                const applyHeight = (value, { persist = false } = {}) => {
                    const clamped = clampHeight(value);
                    terminalHeight = clamped;
                    terminalPanel.style.height = `${clamped}px`;
                    if (persist) {
                        persistHeight();
                    }
                    scheduleTerminalFit();
                    return clamped;
                };

                const restoreHeightFromStorage = () => {
                    if (typeof window.localStorage === 'undefined') {
                        terminalHeight = clampHeight(terminalPanel.getBoundingClientRect().height || 260);
                        return;
                    }
                    let stored = null;
                    try {
                        stored = window.localStorage.getItem(terminalStorageKey);
                    } catch (error) {
                        stored = null;
                    }
                    const numeric = stored === null ? NaN : Number(stored);
                    if (Number.isFinite(numeric)) {
                        applyHeight(numeric);
                    } else {
                        terminalHeight = clampHeight(terminalPanel.getBoundingClientRect().height || 260);
                    }
                };

                const setCollapsed = (value) => {
                    const collapsed = Boolean(value);
                    if (terminalCollapsed === collapsed) {
                        return;
                    }
                    terminalCollapsed = collapsed;
                    terminalPanel.classList.toggle('is-collapsed', collapsed);
                    if (terminalToggleButton) {
                        terminalToggleButton.setAttribute('aria-expanded', String(!collapsed));
                        terminalToggleButton.textContent = collapsed ? 'Show terminal' : 'Hide terminal';
                    }

                    if (collapsed) {
                        terminalPanel.style.height = '';
                        return;
                    }

                    applyHeight(terminalHeight || clampHeight(terminalPanel.getBoundingClientRect().height || 260));

                    if (terminalPanel) {
                        const handleTransitionEnd = (event) => {
                            if (event.target !== terminalPanel || event.propertyName !== 'height') {
                                return;
                            }
                            terminalPanel.removeEventListener('transitionend', handleTransitionEnd);
                            scheduleTerminalFit();
                        };
                        terminalPanel.addEventListener('transitionend', handleTransitionEnd, { once: true });
                    }

                    const instance = ensureTerminalInstance();
                    if (instance) {
                        instance.focus();
                        if (typeof instance.scrollToBottom === 'function') {
                            instance.scrollToBottom();
                        }
                    }

                    connectTerminal();
                };

                restoreHeightFromStorage();

                if (terminalToggleButton) {
                    terminalToggleButton.addEventListener('click', () => {
                        setCollapsed(!terminalCollapsed);
                    });
                }

                if (terminalResizeHandle) {
                    terminalResizeHandle.addEventListener('pointerdown', (event) => {
                        if (event.button !== 0) {
                            return;
                        }
                        if (terminalCollapsed) {
                            setCollapsed(false);
                        }
                        event.preventDefault();
                        const startY = event.clientY;
                        const startHeight = terminalPanel.getBoundingClientRect().height;

                        const handleMove = (moveEvent) => {
                            const delta = startY - moveEvent.clientY;
                            const next = clampHeight(startHeight + delta);
                            applyHeight(next);
                        };

                        const handleUp = () => {
                            document.removeEventListener('pointermove', handleMove);
                            document.removeEventListener('pointerup', handleUp);
                            persistHeight();
                            scheduleTerminalFit();
                        };

                        document.addEventListener('pointermove', handleMove);
                        document.addEventListener('pointerup', handleUp);
                    });

                    terminalResizeHandle.addEventListener('keydown', (event) => {
                        if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {
                            return;
                        }
                        event.preventDefault();
                        if (terminalCollapsed) {
                            setCollapsed(false);
                        }
                        const offset = event.key === 'ArrowUp' ? 32 : -32;
                        const next = clampHeight((terminalHeight || terminalPanel.getBoundingClientRect().height) + offset);
                        applyHeight(next, { persist: true });
                    });

                    terminalResizeHandle.addEventListener('dblclick', () => {
                        if (terminalCollapsed) {
                            setCollapsed(false);
                        }
                        applyHeight(clampHeight(260), { persist: true });
                    });
                }

                window.addEventListener('resize', () => {
                    if (terminalCollapsed) {
                        return;
                    }
                    const current = terminalHeight || terminalPanel.getBoundingClientRect().height;
                    const clamped = clampHeight(current);
                    if (clamped !== current) {
                        applyHeight(clamped, { persist: true });
                    } else {
                        scheduleTerminalFit();
                    }
                });

                setCollapsed(false);
                ensureTerminalInstance();
                connectTerminal();
            }

            window.addEventListener('beforeunload', () => {
                if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                    try {
                        terminalSocket.close();
                    } catch (error) {
                        // Swallow shutdown errors.
                    }
                }
            });

            function initialise() {
                const initialFallback = fallbackMarkdownFor(resolvedRootPath || originalPathArgument || 'the selected path');
                renderMarkdown(state.content || initialFallback, { updateCurrent: true });
                renderFileList();
                updateHeader();
                if (state.error) {
                    setStatus(state.error);
                }
                setupActions();
                setupTerminalPanel();
                connectWebSocket();
                if (!currentFile && files.length) {
                    currentFile = files[0].relativePath;
                }

                if (!initialFileFromLocation && currentFile) {
                    loadFile(currentFile, { replaceHistory: true });
                }
            }

            window.addEventListener('popstate', () => {
                const targetFile = fileFromSearch(window.location.search);
                if (targetFile) {
                    if (targetFile !== currentFile) {
                        loadFile(targetFile, { skipHistory: true, replaceHistory: true });
                    }
                } else {
                    resetViewToFallback({ skipHistory: true });
                }
            });

            initialise();

            if (initialFileFromLocation) {
                loadFile(initialFileFromLocation, { replaceHistory: true });
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    </script>
</body>

</html>
